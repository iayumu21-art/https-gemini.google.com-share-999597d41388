<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kodo to Doshisha Univ - 1st Period Rush</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0c4a6e;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 10px;
        }
        canvas {
            background: #bae6fd;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            touch-action: none;
            cursor: pointer;
        }
        .controls {
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 16px;
            text-align: center;
            width: 95%;
            max-width: 500px;
            border: 1px solid rgba(255,255,255,0.3);
            transition: opacity 0.3s ease;
        }
        .hidden-ui {
            opacity: 0;
            pointer-events: none;
        }
        @keyframes cut-in {
            0% { transform: translateX(-100%) skewX(-20deg); opacity: 0; }
            20% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            80% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            100% { transform: translateX(100%) skewX(-20deg); opacity: 0; }
        }
        #cut-in-overlay {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 100px;
            background: #ef4444;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
            transform: translateY(-50%) skewX(-20deg);
            border-top: 4px solid white;
            border-bottom: 4px solid white;
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.8);
        }
        #cut-in-text {
            color: white;
            font-size: 32px;
            font-weight: 900;
            font-style: italic;
            text-shadow: 3px 3px 0 #000;
            transform: skewX(20deg);
        }
        @media (min-width: 640px) {
            #cut-in-text { font-size: 40px; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="cut-in-overlay">
            <div id="cut-in-text">1限に間に合わない！</div>
        </div>

        <div class="flex justify-between w-full max-w-[800px] px-4 mb-2">
            <div id="levelDisplay" class="text-sm sm:text-lg font-bold text-sky-700">LEVEL 1: 通学路</div>
            <div id="scoreDisplay" class="text-sm sm:text-lg font-mono text-orange-600">SCORE: 0</div>
        </div>
        
        <canvas id="gameCanvas"></canvas>

        <div id="uiPanel" class="controls">
            <div id="upload-section">
                <input type="file" id="imageInput" accept="image/*" class="hidden">
                <button onclick="document.getElementById('imageInput').click()" 
                        class="bg-orange-500 hover:bg-orange-400 text-white font-bold py-3 px-8 rounded-full transition duration-300 shadow-lg text-base border-b-4 border-orange-700 active:border-b-0 active:translate-y-1">
                    キャラを選んで登校開始！
                </button>
            </div>
            <p id="status" class="text-xs sm:text-sm text-sky-900 font-bold mt-2">操作: 長押しで高ジャンプ！</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('imageInput');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const uiPanel = document.getElementById('uiPanel');
        const cutInOverlay = document.getElementById('cut-in-overlay');

        // --- Audio System ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'jump') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.05);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(); osc.stop(now + 0.05);
            } else if (type === 'coin') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(); osc.stop(now + 0.15);
            } else if (type === 'bonus') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.exponentialRampToValueAtTime(2400, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(); osc.stop(now + 0.3);
            } else if (type === 'gameover') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(40, now + 0.4);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.4);
                osc.start(); osc.stop(now + 0.4);
            } else if (type === 'cutin') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.start(); osc.stop(now + 0.3);
            }
        }

        // --- Constants ---
        const GRAVITY = 1.1;             
        const INITIAL_JUMP = -13;        
        const JUMP_SUSTAIN = -1.0;       
        const MAX_JUMP_TIME = 12;        
        const GROUND_HEIGHT = 80; 
        const PLAYER_SIZE = 80;
        const MAX_SLOPE_ANGLE = -0.22;   
        const LEVEL_GOAL_SCORE = 6000;   
        const SLOPE_START_SCORE = 1200; 
        const BASE_SCROLL_SPEED = 7.5;   

        // State
        let player = {
            x: 180, y: 0, vy: 0,
            width: PLAYER_SIZE, height: PLAYER_SIZE,
            img: null, bobbing: 0, scaleY: 1,
            isJumping: false, jumpCounter: 0
        };

        let isPressing = false;
        let currentLevel = 1;
        let enemies = [];
        let coins = [];
        let backgroundItems = [];
        let decos = [];
        let goalItem = null;
        let frameCount = 0;
        let score = 0;
        let totalCoinsSpawned = 0;
        let totalCoinsCollected = 0;
        let finalScore = 0;
        let gameState = 'WAITING';
        let cameraOffset = 0;
        let particles = [];
        let nextSpawnTime = 0;

        function resize() {
            const containerWidth = window.innerWidth * 0.95;
            canvas.width = Math.min(containerWidth, 800);
            canvas.height = Math.min(window.innerHeight * 0.6, 450);
            initBackground();
            player.x = canvas.width * 0.22;
        }

        function initBackground() {
            backgroundItems = [];
            decos = [];
            for(let i=0; i<6; i++) {
                backgroundItems.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height / 3),
                    w: Math.random() * 100 + 60,
                    h: Math.random() * 40 + 20,
                    speed: Math.random() * 0.2 + 0.1
                });
            }
            for(let i=0; i<3; i++) {
                decos.push({ x: i * 450 });
            }
        }

        window.addEventListener('resize', resize);
        resize();

        imageInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    player.img = img;
                    currentLevel = 1;
                    totalCoinsSpawned = 0;
                    totalCoinsCollected = 0;
                    triggerStartSequence();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function triggerStartSequence() {
            uiPanel.classList.add('hidden-ui');
            cutInOverlay.style.display = 'flex';
            cutInOverlay.style.animation = 'cut-in 1.5s ease-in-out forwards';
            playSound('cutin');
            
            setTimeout(() => {
                cutInOverlay.style.display = 'none';
                cutInOverlay.style.animation = '';
                startGame();
            }, 1500);
        }

        function startGame() {
            score = 0;
            enemies = [];
            coins = [];
            particles = [];
            decos = [{x: 450}, {x: 900}, {x: 1350}];
            goalItem = null;
            gameState = 'PLAYING';
            frameCount = 0;
            cameraOffset = 0;
            nextSpawnTime = 0;
            updateLevelUI();
            player.y = getGroundY(player.x) - player.height;
            player.vy = 0;
            player.isJumping = false;
            uiPanel.classList.add('hidden-ui');
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function getCurrentSlope() {
            if (currentLevel === 1) return 0;
            if (score < SLOPE_START_SCORE) return 0;
            const progress = Math.min((score - SLOPE_START_SCORE) / 2500, 1);
            return MAX_SLOPE_ANGLE * progress;
        }

        function getGroundY(x) {
            const baseLine = canvas.height - GROUND_HEIGHT;
            const slope = getCurrentSlope();
            if (slope === 0) return baseLine;
            return baseLine - (canvas.width - x) * Math.tan(slope);
        }

        function updateLevelUI() {
            if (currentLevel === 1) {
                levelDisplay.textContent = "LEVEL 1: 通学路";
                levelDisplay.className = "text-sm sm:text-lg font-bold text-sky-600";
            } else {
                levelDisplay.textContent = "LEVEL 2: キャンパス";
                levelDisplay.className = "text-sm sm:text-lg font-bold text-orange-600";
            }
        }

        function spawnParticle(x, y, color = '#fbbf24') {
            for(let i=0; i<8; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 15,
                    color: color
                });
            }
        }

        const onPress = (e) => {
            if (e && e.type === 'keydown' && e.code !== 'Space') return;
            if (e && e.cancelable) e.preventDefault();
            isPressing = true;
            if (gameState === 'GAMEOVER' || gameState === 'CLEARING') {
                currentLevel = 1;
                totalCoinsSpawned = 0;
                totalCoinsCollected = 0;
                triggerStartSequence(); 
                return;
            }
            if (gameState === 'WAITING' && player.img) {
                triggerStartSequence(); return;
            }
            if (gameState === 'PLAYING') {
                const groundLimit = getGroundY(player.x) - player.height;
                if (player.y >= groundLimit - 15) { 
                    player.vy = INITIAL_JUMP;
                    player.isJumping = true;
                    player.jumpCounter = 0;
                    playSound('jump');
                }
            }
        };

        const onRelease = () => {
            isPressing = false;
            player.isJumping = false;
        };

        window.addEventListener('keydown', onPress);
        window.addEventListener('keyup', onRelease);
        canvas.addEventListener('mousedown', onPress);
        window.addEventListener('mouseup', onRelease);
        canvas.addEventListener('touchstart', onPress, {passive: false});
        window.addEventListener('touchend', onRelease);

        function update() {
            if (gameState !== 'PLAYING') return;
            frameCount++;
            score += 2; 
            scoreDisplay.textContent = `SCORE: ${Math.floor(score / 10)}`;
            
            const scrollSpeed = BASE_SCROLL_SPEED + (score / 4000);

            if (currentLevel === 2) {
                const targetOffset = (canvas.width - player.x) * Math.tan(getCurrentSlope()) * 0.75;
                cameraOffset += (targetOffset - cameraOffset) * 0.1;
            }

            if (isPressing && player.isJumping) {
                if (player.jumpCounter < MAX_JUMP_TIME) {
                    player.vy += JUMP_SUSTAIN; 
                    player.jumpCounter++;
                } else {
                    player.isJumping = false;
                }
            }

            player.vy += GRAVITY;
            player.y += player.vy;

            const groundY = getGroundY(player.x) - player.height;
            if (player.y > groundY) {
                player.y = groundY;
                player.vy = 0;
                player.isJumping = false;
                player.scaleY = 1.0; 
                player.bobbing = Math.sin(frameCount * 0.3) * 3;
            } else {
                player.scaleY = 1.0 + Math.abs(player.vy) * 0.02;
            }

            backgroundItems.forEach(cloud => {
                cloud.x -= cloud.speed;
                if (cloud.x + cloud.w < 0) cloud.x = canvas.width + 50;
            });

            decos.forEach(d => {
                d.x -= scrollSpeed * 0.9;
                if (d.x < -100) d.x = canvas.width + 450;
            });

            if (frameCount % 60 === 0 && !goalItem) { 
                const spawnX = canvas.width + 50;
                const groundAtSpawn = getGroundY(spawnX);
                const isBonus = Math.random() > 0.9;
                const cy = currentLevel === 2 
                    ? groundAtSpawn - 50 - Math.random() * 80 
                    : groundAtSpawn - 60 - Math.random() * 120;

                coins.push({ 
                    x: spawnX, y: cy, w: isBonus?40:30, h: isBonus?40:30, 
                    type: isBonus?'BONUS':'NORMAL' 
                });
                totalCoinsSpawned++;
            }

            for(let i=coins.length-1; i>=0; i--) {
                let c = coins[i];
                c.x -= scrollSpeed;
                if (Math.abs(player.x + player.width/2 - (c.x + c.w/2)) < 45 &&
                    Math.abs(player.y + player.height/2 - (c.y + c.h/2)) < 45) {
                    if (c.type === 'BONUS') { score += 1000; playSound('bonus'); spawnParticle(c.x, c.y, '#60a5fa'); }
                    else { score += 300; playSound('coin'); spawnParticle(c.x, c.y, '#fbbf24'); }
                    totalCoinsCollected++;
                    coins.splice(i, 1); continue;
                }
                if (c.x < -100) coins.splice(i, 1);
            }

            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            });

            if (score >= LEVEL_GOAL_SCORE && !goalItem) {
                goalItem = { x: canvas.width + 200, w: 350, h: 250, type: currentLevel === 1 ? 'STATION' : 'UNIV' };
            }

            if (goalItem) {
                goalItem.x -= scrollSpeed * 0.85;
                if (player.x > goalItem.x + 150) {
                    if (currentLevel === 1) { 
                        currentLevel = 2; 
                        startGame(); 
                    }
                    else { 
                        finalScore = Math.floor(score / 10);
                        gameState = 'CLEARING'; 
                        uiPanel.classList.remove('hidden-ui'); 
                    }
                }
            } else if (frameCount > nextSpawnTime) {
                const r = Math.random();
                let spawnDelay = 60 + Math.random() * 40; 
                if (r > 0.9) {
                    enemies.push({ x: canvas.width, w: 45, h: 40, speed: scrollSpeed * 1.05, type: 'BIRD', ph: Math.random()*10 });
                } else if (r > 0.7 && currentLevel === 2) {
                    for(let k=0; k<2; k++) { 
                        enemies.push({ x: canvas.width + k*70, w: 40, h: 65, speed: scrollSpeed * 0.8, type: 'STUDENT', ph: Math.random()*10 });
                    }
                    spawnDelay = 140;
                } else if (r > 0.5 && currentLevel === 2) {
                    enemies.push({ x: canvas.width, w: 35, h: 35, speed: scrollSpeed * 1.2, type: 'TRASH', rot: 0 });
                } else {
                    enemies.push({ x: canvas.width, w: 40, h: 45 + Math.random()*20, speed: scrollSpeed, type: 'CONE' });
                }
                nextSpawnTime = frameCount + Math.max(spawnDelay - Math.floor(score/1500), 40);
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.x -= e.speed;
                const ey = getGroundY(e.x);
                if (e.type === 'BIRD') e.y = ey - 150 + Math.sin(frameCount * 0.15 + e.ph) * 30;
                else if (e.type === 'STUDENT') e.y = ey - e.h + Math.abs(Math.sin(frameCount * 0.2 + e.ph)) * 10;
                else { e.y = ey - e.h; if (e.type === 'TRASH') e.rot += 0.35; }
                
                const pInset = 32; 
                if (player.x + pInset < e.x + e.w - 12 && player.x + player.width - pInset > e.x + 12 &&
                    player.y + 25 < e.y + e.h - 12 && player.y + player.height - 12 > e.y + 12) {
                    gameState = 'GAMEOVER';
                    playSound('gameover');
                    uiPanel.classList.remove('hidden-ui');
                }
                if (e.x < -600) enemies.splice(i, 1);
            }
        }

        function draw() {
            const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
            sky.addColorStop(0, '#0ea5e9'); sky.addColorStop(0.7, '#fef08a'); sky.addColorStop(1, '#fdba74');
            ctx.fillStyle = sky; ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            backgroundItems.forEach(cloud => {
                ctx.beginPath(); ctx.ellipse(cloud.x, cloud.y, cloud.w/2, cloud.h/2, 0, 0, Math.PI*2); ctx.fill();
            });
            ctx.restore();

            ctx.save();
            ctx.translate(0, cameraOffset);

            ctx.fillStyle = currentLevel === 1 ? '#94a3b8' : '#475569';
            ctx.beginPath(); ctx.moveTo(-100, canvas.height + 600);
            for(let x = -100; x <= canvas.width + 200; x += 20) { ctx.lineTo(x, getGroundY(x)); }
            ctx.lineTo(canvas.width + 200, canvas.height + 600); ctx.closePath(); ctx.fill();
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 4; ctx.stroke();

            decos.forEach(d => {
                const dy = getGroundY(d.x);
                if (currentLevel === 1) {
                    ctx.fillStyle = '#64748b'; ctx.fillRect(d.x, dy-240, 12, 240);
                    ctx.fillStyle = '#475569'; ctx.fillRect(d.x-10, dy-220, 32, 8);
                    ctx.fillRect(d.x-10, dy-200, 32, 6);
                } else {
                    const lx = d.x;
                    const ly = dy - 220;
                    ctx.fillStyle = '#1a1a1a'; ctx.fillRect(lx - 4, ly, 8, 220); 
                    ctx.fillRect(lx - 15, dy - 15, 30, 15); 
                    ctx.beginPath(); ctx.lineWidth = 3; ctx.strokeStyle = '#1a1a1a';
                    ctx.moveTo(lx, ly + 40); ctx.quadraticCurveTo(lx + 25, ly + 20, lx + 20, ly + 60); ctx.stroke();
                    ctx.fillStyle = '#262626'; ctx.beginPath(); ctx.moveTo(lx - 12, ly); ctx.lineTo(lx + 12, ly); ctx.lineTo(lx + 18, ly - 35); ctx.lineTo(lx - 18, ly - 35); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#1a1a1a'; ctx.beginPath(); ctx.moveTo(lx - 22, ly - 35); ctx.lineTo(lx + 22, ly - 35); ctx.lineTo(lx, ly - 55); ctx.closePath(); ctx.fill();
                    ctx.save();
                    const glow = ctx.createRadialGradient(lx, ly - 18, 2, lx, ly - 18, 25);
                    glow.addColorStop(0, '#fff9c4'); glow.addColorStop(0.5, 'rgba(253, 224, 71, 0.8)'); glow.addColorStop(1, 'rgba(253, 224, 71, 0)');
                    ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(lx, ly - 18, 25, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                    ctx.fillStyle = '#fef08a'; ctx.beginPath(); ctx.arc(lx, ly - 18, 6, 0, Math.PI * 2); ctx.fill();
                }
            });

            if (goalItem) {
                const gy = getGroundY(goalItem.x);
                ctx.save(); ctx.translate(goalItem.x, gy);
                if (goalItem.type === 'STATION') {
                    ctx.fillStyle = '#cbd5e1'; ctx.fillRect(0, -180, goalItem.w, 180);
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(-10, -190, goalItem.w+20, 20);
                    ctx.fillStyle = '#475569'; 
                    for(let i=0; i<3; i++) ctx.fillRect(40 + i*100, -120, 60, 120);
                    ctx.fillStyle = 'white'; ctx.fillRect(50, -170, goalItem.w-100, 40);
                    ctx.strokeStyle = '#1d4ed8'; ctx.lineWidth = 3; ctx.strokeRect(50, -170, goalItem.w-100, 40);
                    ctx.fillStyle = '#1d4ed8'; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center';
                    ctx.fillText('興戸駅 (Kodo St.)', goalItem.w/2, -142);
                } else {
                    ctx.fillStyle = '#7f1d1d'; ctx.fillRect(0, -220, 40, 220); ctx.fillRect(goalItem.w-40, -220, 40, 220);
                    ctx.fillStyle = '#450a0a'; ctx.fillRect(0, -230, 50, 20); ctx.fillRect(goalItem.w-50, -230, 50, 20);
                    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(40, -180, goalItem.w-80, 180);
                    ctx.fillStyle = '#fef3c7'; ctx.font = 'bold 28px serif'; ctx.textAlign = 'center';
                    ctx.fillText('同志社大学', goalItem.w/2, -100);
                }
                ctx.restore();
            }

            coins.forEach(c => {
                ctx.save(); ctx.translate(c.x + c.w/2, c.y + c.h/2);
                const isBonus = c.type === 'BONUS';
                if (isBonus) { ctx.shadowBlur = 15; ctx.shadowColor = '#60a5fa'; ctx.fillStyle = '#eff6ff'; }
                else { ctx.fillStyle = '#fbbf24'; }
                ctx.beginPath(); ctx.arc(0,0, c.w/2, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = isBonus ? '#3b82f6' : '#d97706'; ctx.lineWidth = 3; ctx.stroke();
                ctx.fillStyle = isBonus ? '#1d4ed8' : '#d97706'; ctx.font = `bold ${isBonus?24:18}px sans-serif`; 
                ctx.textAlign = 'center'; ctx.fillText(isBonus ? '★' : '¥', 0, isBonus ? 8 : 7);
                ctx.restore();
            });

            particles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 15; ctx.fillRect(p.x, p.y, 4, 4);
            });
            ctx.globalAlpha = 1.0;

            enemies.forEach(e => {
                ctx.save(); ctx.translate(e.x + e.w/2, e.y + e.h/2);
                if (e.type === 'BIRD') {
                    ctx.fillStyle = '#1e293b'; const wing = Math.sin(frameCount * 0.4 + e.ph) * 18;
                    ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(0, wing); ctx.lineTo(20, 0); ctx.lineTo(0, -wing); ctx.fill();
                } else if (e.type === 'STUDENT') {
                    ctx.fillStyle = '#3b82f6'; ctx.fillRect(-15, -20, 30, 40);
                    ctx.fillStyle = '#fca5a5'; ctx.beginPath(); ctx.arc(0, -35, 12, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(-12, 20, 8, 15); ctx.fillRect(4, 20, 8, 15);
                } else if (e.type === 'TRASH') {
                    ctx.rotate(e.rot); ctx.fillStyle = '#94a3b8'; ctx.fillRect(-e.w/2, -e.h/2, e.w, e.h);
                } else {
                    ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.moveTo(-e.w/2, e.h/2); ctx.lineTo(0, -e.h/2); ctx.lineTo(e.w/2, e.h/2); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.fillRect(-e.w/2+10, e.h/2-10, e.w-20, 4);
                }
                ctx.restore();
            });

            ctx.save();
            const py = player.y + player.height / 2 + (player.vy === 0 ? player.bobbing : 0);
            ctx.translate(player.x + player.width / 2, py);
            ctx.scale(1 / player.scaleY, player.scaleY);
            const aura = ctx.createRadialGradient(0, 0, 0, 0, 0, player.width/1.1);
            aura.addColorStop(0, 'rgba(255, 255, 255, 0.4)'); aura.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = aura; ctx.beginPath(); ctx.arc(0, 0, player.width/1.1, 0, Math.PI*2); ctx.fill();
            ctx.scale(-1, 1);
            if (player.img) ctx.drawImage(player.img, -player.width/2, -player.height/2 - 15, player.width, player.height);
            else { ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.strokeRect(-player.width/2, -player.height/2, player.width, player.height); }
            ctx.restore();
            ctx.restore(); 

            // --- RESULT UI RENDERING ---
            const isMobile = canvas.width < 500;

            if (gameState === 'GAMEOVER') {
                ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle = '#ef4444'; ctx.textAlign = 'center'; 
                ctx.font = `bold ${isMobile ? 32 : 45}px sans-serif`;
                ctx.fillText('遅刻確定...！', canvas.width/2, canvas.height/2 - 20);
                ctx.fillStyle = 'white'; ctx.font = `${isMobile ? 18 : 22}px sans-serif`; 
                ctx.fillText('タップしてリベンジ', canvas.width/2, canvas.height/2 + 40);
            } else if (gameState === 'CLEARING') {
                ctx.fillStyle = 'rgba(15, 23, 42, 0.95)'; ctx.fillRect(0,0,canvas.width,canvas.height);
                
                // タイトル
                ctx.fillStyle = '#4ade80'; ctx.textAlign = 'center'; 
                ctx.font = `bold ${isMobile ? 28 : 40}px sans-serif`;
                ctx.fillText('無事に間に合った！', canvas.width/2, canvas.height * 0.22);
                
                // スコア
                ctx.fillStyle = '#fbbf24'; 
                ctx.font = `bold ${isMobile ? 20 : 28}px monospace`;
                ctx.fillText(`TOTAL SCORE: ${finalScore}`, canvas.width/2, canvas.height * 0.35);
                
                // ランク計算
                const ratio = totalCoinsSpawned > 0 ? (totalCoinsCollected / totalCoinsSpawned) : 0;
                let rank = "C";
                let rankColor = "#94a3b8";
                if (ratio >= 1.0) { rank = "S"; rankColor = "#fbbf24"; }
                else if (ratio >= 0.8) { rank = "A"; rankColor = "#f87171"; }
                else if (ratio >= 0.5) { rank = "B"; rankColor = "#60a5fa"; }

                ctx.fillStyle = "white"; 
                ctx.font = `${isMobile ? 14 : 18}px sans-serif`;
                ctx.fillText(`コイン回収率: ${Math.floor(ratio * 100)}%`, canvas.width/2, canvas.height * 0.44);

                // ランク表示 (サイズ調整: 前回の80/120から60/100へ縮小)
                ctx.fillStyle = rankColor; 
                ctx.font = `bold ${isMobile ? 60 : 100}px sans-serif`;
                ctx.shadowBlur = 15; ctx.shadowColor = rankColor;
                ctx.fillText(rank, canvas.width/2, canvas.height * 0.72);
                ctx.shadowBlur = 0;

                // 操作案内
                ctx.fillStyle = 'rgba(255,255,255,0.7)'; 
                ctx.font = `${isMobile ? 13 : 15}px sans-serif`;
                ctx.fillText('タップしてもう一度登校する', canvas.width/2, canvas.height * 0.9);
            }
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
        gameLoop();
    </script>
</body>
</html>
