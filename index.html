<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã•ã„ã“ã‚ã‚¸ãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        body {
            font-family: 'DotGothic16', sans-serif;
            background-color: #1a1a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            margin: 0;
        }
        #app {
            height: 100vh;
            max-height: 100vh;
        }
        .battle-log {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(0,0,0,0.8);
            min-height: 60px;
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .dodge {
            animation: dodge 0.4s ease-in-out;
        }
        @keyframes dodge {
            0% { transform: translateX(0); }
            25% { transform: translateX(-20px); }
            75% { transform: translateX(20px); }
            100% { transform: translateX(0); }
        }
        .dice {
            display: inline-block;
            width: 60px;
            height: 60px;
            line-height: 60px;
            text-align: center;
            background: white;
            color: black;
            border-radius: 8px;
            font-size: 32px;
            font-weight: bold;
        }
        @keyframes aura-pulse {
            0% { filter: drop-shadow(0 0 5px #fff); transform: scale(1); }
            50% { filter: drop-shadow(0 0 15px #00ffff); transform: scale(1.1); }
            100% { filter: drop-shadow(0 0 5px #fff); transform: scale(1); }
        }
        .awakened {
            animation: aura-pulse 1.5s infinite ease-in-out;
        }
        @keyframes cutin-in {
            0% { transform: translateX(-100%) skewX(-20deg); opacity: 0; }
            20% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            80% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            100% { transform: translateX(100%) skewX(-20deg); opacity: 0; }
        }
        .cutin-active {
            animation: cutin-in 1.5s ease-in-out forwards;
        }
        .text-glow {
            text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px currentColor;
        }
        .flash-dark {
            animation: flash-dark-anim 1.2s ease-out;
        }
        @keyframes flash-dark-anim {
            0% { background-color: #000; opacity: 1; }
            50% { background-color: #200040; opacity: 0.8; }
            100% { background-color: transparent; opacity: 0; }
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f00;
            z-index: 100;
            pointer-events: none;
            animation: fall linear forwards;
        }
        @keyframes fall {
            to { transform: translateY(100vh) rotate(360deg); }
        }
        @keyframes victory-zoom {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .victory-anim {
            animation: victory-zoom 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
    </style>
</head>
<body class="flex items-center justify-center">

    <div id="app" class="relative w-full max-w-md bg-gray-900 p-2 sm:p-4 rounded-none sm:rounded-xl shadow-2xl flex flex-col border-4 border-gray-700">
        <!-- Character Selection Screen -->
        <div id="start-screen" class="flex-grow flex flex-col items-center justify-center overflow-y-auto">
            <h1 class="text-2xl font-bold mb-4 text-yellow-500 text-center text-glow">ã•ã„ã“ã‚ã‚¸ãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ</h1>
            <p class="mb-4 text-sm text-gray-300">å†’é™ºè€…ã‚’é¸ã‚“ã§ãã ã•ã„</p>
            
            <div class="grid grid-cols-2 gap-2 w-full mb-4">
                <button onclick="window.showDetails('ayumu')" class="bg-blue-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">âš”ï¸</div>
                    <div class="text-xs font-bold">ã‚¢ãƒ¦ãƒ  (å‹‡è€…)</div>
                </button>
                <button onclick="window.showDetails('hikaru')" class="bg-green-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ¥·</div>
                    <div class="text-xs font-bold">ãƒ’ã‚«ãƒ« (å¿è€…)</div>
                </button>
                <button onclick="window.showDetails('shunsuke')" class="bg-red-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ›¡ï¸</div>
                    <div class="text-xs font-bold">ã‚·ãƒ¥ãƒ³ã‚¹ã‚± (æˆ¦å£«)</div>
                </button>
                <button onclick="window.showDetails('hiiro')" class="bg-purple-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ§™</div>
                    <div class="text-xs font-bold">ãƒ’ã‚¤ãƒ­ (é­”æ³•ä½¿ã„)</div>
                </button>
            </div>

            <div id="char-detail" class="hidden w-full bg-black p-3 border-2 border-yellow-500 rounded mb-2">
                <h2 id="detail-name" class="text-lg font-bold text-yellow-400"></h2>
                <div id="detail-stats" class="text-xs mb-2 text-gray-300 border-b border-gray-700 pb-2"></div>
                <div class="text-[10px] text-gray-400 font-bold mt-2 mb-1">ã€ã‚¹ã‚­ãƒ«ãƒªã‚¹ãƒˆ (ãƒ€ã‚¤ã‚¹ã®ç›®)ã€‘</div>
                <ul id="detail-skills" class="text-[9px] list-none mb-3 grid grid-cols-1 gap-1 text-gray-200"></ul>
                <button onclick="window.startGame()" class="w-full bg-yellow-600 hover:bg-yellow-500 py-2 rounded font-bold text-white text-sm">å†’é™ºã«å‡ºã‚‹</button>
            </div>
        </div>

        <!-- Battle Screen -->
        <div id="battle-screen" class="hidden h-full flex flex-col relative overflow-hidden">
            <div id="flash-overlay" class="absolute inset-0 z-50 pointer-events-none"></div>

            <div id="cutin-layer" class="pointer-events-none absolute inset-0 z-40 flex items-center justify-center opacity-0">
                <div id="cutin-banner" class="w-[150%] h-24 bg-gradient-to-r from-transparent via-white/20 to-transparent border-y-4 border-white flex items-center justify-center">
                    <span id="cutin-text" class="text-4xl font-black italic tracking-tighter text-glow"></span>
                </div>
            </div>

            <div class="relative flex flex-col h-40 bg-gray-800 rounded-t-lg border-b-2 border-gray-700 p-2">
                <div class="w-full mb-auto">
                    <div class="flex justify-between text-xs text-white mb-1">
                        <span id="enemy-name" class="font-bold drop-shadow-lg"></span>
                        <span id="enemy-hp-text" class="font-bold"></span>
                    </div>
                    <div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden border border-gray-600">
                        <div id="enemy-hp-bar" class="bg-red-500 h-full transition-all duration-300"></div>
                    </div>
                    <div id="enemy-status" class="flex mt-1 gap-1 min-h-[14px]"></div>
                </div>
                <div class="flex items-center justify-center flex-grow">
                    <div id="enemy-sprite" class="text-6xl transition-all duration-500 drop-shadow-lg">ğŸ‘¾</div>
                </div>
            </div>

            <!-- Player Area -->
            <div class="p-2 bg-gray-900 border-x-2 border-gray-700 flex flex-col items-center">
                <div id="player-sprite-container" class="mb-1 transition-transform">
                    <div id="player-sprite" class="text-4xl drop-shadow-md"></div>
                </div>
                <div class="w-full">
                    <div class="flex justify-between text-xs mb-1">
                        <span id="player-name" class="font-bold text-blue-400"></span>
                        <span id="player-hp-text"></span>
                    </div>
                    <div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden mb-1 border border-gray-600">
                        <div id="player-hp-bar" class="bg-green-500 h-full transition-all duration-300"></div>
                    </div>
                    <div class="flex justify-between text-[10px] text-gray-300">
                        <span id="player-mp-text"></span>
                        <div id="player-status" class="flex gap-1 min-h-[12px]"></div>
                    </div>
                </div>
            </div>

            <div id="battle-log" class="battle-log p-2 text-[11px] border-2 border-gray-700 bg-black font-mono leading-tight">
                <div>å†’é™ºãŒå§‹ã¾ã£ãŸï¼</div>
            </div>

            <div id="action-panel" class="grid grid-cols-2 gap-1 p-2 bg-gray-800 rounded-b-lg border-t-2 border-gray-700">
                <button onclick="window.command('attack')" class="bg-gray-700 hover:bg-gray-600 py-2 rounded text-white font-bold text-sm border-b-2 border-gray-900">æ”»æ’ƒ</button>
                <button onclick="window.command('heal')" class="bg-emerald-700 hover:bg-emerald-600 py-2 rounded text-white font-bold text-sm border-b-2 border-emerald-900">å›å¾©</button>
                <button id="skill-btn" onclick="window.command('skill')" class="bg-blue-700 hover:bg-blue-600 py-2 rounded col-span-2 text-white font-bold text-sm border-b-2 border-blue-900">ã‚¹ã‚­ãƒ« (MP 1)</button>
            </div>
        </div>

        <!-- Result Screen -->
        <div id="result-screen" class="hidden flex-grow flex flex-col items-center justify-center text-center z-50 overflow-y-auto pt-4 pb-4">
            <h2 id="result-title" class="text-3xl font-bold mb-4 drop-shadow-lg victory-anim"></h2>
            
            <div id="adventure-stats" class="w-full px-4 mb-4 hidden">
                <div class="bg-black/60 border-2 border-yellow-600 rounded-lg p-3 text-left">
                    <h3 class="text-yellow-400 font-bold border-b border-yellow-800 mb-2 pb-1 text-center">âœ¨ å†’é™ºã®è¨˜éŒ² âœ¨</h3>
                    <div class="grid grid-cols-1 gap-2 text-sm">
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">å‹‡è€…:</span>
                            <span id="stat-hero" class="text-white font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">ä¸ãˆãŸç·ãƒ€ãƒ¡ãƒ¼ã‚¸:</span>
                            <span id="stat-dmg-dealt" class="text-red-400 font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">å—ã‘ãŸç·ãƒ€ãƒ¡ãƒ¼ã‚¸:</span>
                            <span id="stat-dmg-taken" class="text-orange-400 font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">ã‹ã‹ã£ãŸç·ã‚¿ãƒ¼ãƒ³æ•°:</span>
                            <span id="stat-turns" class="text-blue-400 font-bold"></span>
                        </div>
                    </div>
                </div>
            </div>

            <div id="result-message" class="text-sm text-white px-4 mb-6 leading-relaxed"></div>
            
            <div id="thanks-message" class="hidden text-xs text-yellow-200 mb-8 italic">
                ãƒ—ãƒ¬ã‚¤ã—ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ï¼
            </div>

            <div class="flex flex-col gap-2 w-full px-8">
                <button id="next-btn" onclick="window.nextStage()" class="bg-yellow-600 hover:bg-yellow-500 py-3 rounded font-bold text-white text-sm shadow-lg">æ¬¡ã®ã‚¨ãƒªã‚¢ã¸</button>
                <button id="restart-btn" onclick="location.reload()" class="hidden bg-gray-600 hover:bg-gray-500 py-3 rounded font-bold text-white text-sm">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
            </div>
        </div>

        <div id="dice-overlay" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div class="text-center p-6 bg-gray-900 rounded-2xl border-2 border-yellow-500 shadow-2xl">
                <div id="dice-anim" class="dice shadow-lg">?</div>
                <div id="dice-result-name" class="mt-4 text-xl font-bold text-yellow-400"></div>
            </div>
        </div>
    </div>

    <script>
        (function() {
            // --- Sound Engine (Web Audio API) ---
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            function playSE(type) {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                const now = audioCtx.currentTime;

                switch(type) {
                    case 'attack': // Short pulse
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(440, now);
                        osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start();
                        osc.stop(now + 0.1);
                        break;
                    case 'hit': // Noise-like hit
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(220, now);
                        osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start();
                        osc.stop(now + 0.1);
                        break;
                    case 'heal': // Ascending sweep
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(440, now);
                        osc.frequency.exponentialRampToValueAtTime(880, now + 0.3);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.3);
                        osc.start();
                        osc.stop(now + 0.3);
                        break;
                    case 'dice': // Fast blips
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(880, now);
                        gain.gain.setValueAtTime(0.05, now);
                        osc.start();
                        osc.stop(now + 0.05);
                        break;
                    case 'skill': // Power up sound
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(110, now);
                        osc.frequency.exponentialRampToValueAtTime(660, now + 0.4);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                        osc.start();
                        osc.stop(now + 0.4);
                        break;
                    case 'victory': // Upward chords
                        [440, 554, 659].forEach((f, i) => {
                            const o = audioCtx.createOscillator();
                            const g = audioCtx.createGain();
                            o.type = 'square';
                            o.connect(g);
                            g.connect(audioCtx.destination);
                            o.frequency.setValueAtTime(f, now + i * 0.1);
                            g.gain.setValueAtTime(0.05, now + i * 0.1);
                            g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.4);
                            o.start(now + i * 0.1);
                            o.stop(now + i * 0.1 + 0.4);
                        });
                        break;
                    case 'evolve': // Dark descending
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(110, now);
                        osc.frequency.linearRampToValueAtTime(20, now + 1.2);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.linearRampToValueAtTime(0, now + 1.2);
                        osc.start();
                        osc.stop(now + 1.2);
                        break;
                }
            }

            const CHARACTERS = {
                ayumu: { 
                    name: 'ã‚¢ãƒ¦ãƒ ', job: 'å‹‡è€…', icon: 'âš”ï¸', maxHp: 400, atk: 30, maxMp: 5, 
                    skills: [
                        { name: 'å¿…æ®ºã®ä¸€æ’ƒ', desc: 'å¼±ã£ã¦ã„ã‚‹æ•µã«777 / é€šå¸¸ã¯å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸' },
                        { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®ç‰©ç†æ”»æ’ƒãŒ3å€' },
                        { name: 'å¸Œæœ›ã®ä¸€æŒ¯ã‚Š', desc: 'ä¼šå¿ƒã®ä¸€æ’ƒ + æ•µæœ€å¤§HPã®10%åŠ ç®—' },
                        { name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„' },
                        { name: 'ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒ‰', desc: 'é€šå¸¸ãƒ€ãƒ¡ãƒ¼ã‚¸ + ä¸ãˆãŸåˆ†å›å¾©' },
                        { name: 'ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒ‰æ”¹', desc: 'å¿…ä¸­ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸ + ä¸ãˆãŸåˆ†å›å¾©' }
                    ] 
                },
                hikaru: { 
                    name: 'ãƒ’ã‚«ãƒ«', job: 'å¿è€…', icon: 'ğŸ¥·', maxHp: 280, atk: 45, maxMp: 5, 
                    skills: [
                        { name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„' },
                        { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®æ”»æ’ƒãŒ3å€' },
                        { name: 'æ¯’çŸ¢', desc: 'æˆåŠŸç‡80%:æ•µã‚’æ¯’çŠ¶æ…‹ã«ã™ã‚‹' },
                        { name: 'æ‰‹è£å‰£', desc: 'å¨åŠ›35%Ã—5å›é€£ç¶šæ”»æ’ƒ' },
                        { name: 'æ‰‹è£å‰£', desc: 'å¨åŠ›35%Ã—5å›é€£ç¶šæ”»æ’ƒ' },
                        { name: 'æ¯’çŸ¢', desc: 'æˆåŠŸç‡80%:æ•µã‚’æ¯’çŠ¶æ…‹ã«ã™ã‚‹' }
                    ] 
                },
                shunsuke: { 
                    name: 'ã‚·ãƒ¥ãƒ³ã‚¹ã‚±', job: 'æˆ¦å£«', icon: 'ğŸ›¡ï¸', maxHp: 520, atk: 35, maxMp: 3, 
                    skills: [
                        { name: 'å¤§åœ°æ–¬', desc: 'æ”»æ’ƒåŠ›ã®2.5å€ãƒ€ãƒ¡ (ã‚¹ã‚­ãƒ«åå‹•:HP3%æ¶ˆè²»)' },
                        { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®æ”»æ’ƒãŒ3å€ (æ¬¡å›ã®è¢«ãƒ€ãƒ¡è»½æ¸›)' },
                        { name: 'è¶…ãŸã‚ã‚‹', desc: 'æ°¸ç¶šçš„ã«ä¼šå¿ƒç‡UP (è¢«ãƒ€ãƒ¡è»½æ¸›)' },
                        { name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„ (ã‚¹ã‚­ãƒ«åå‹•:HP3%æ¶ˆè²»)' },
                        { name: 'æ­»ã®ä¸€æŒ¯ã‚Š', desc: 'æ•µHPã®70%ã‚’å‰Šã‚‹ (ã‚¹ã‚­ãƒ«åå‹•:HP3%æ¶ˆè²»)' },
                        { name: 'ã“ã‚“ã‚‰ã‚“æ”»æ’ƒ', desc: 'ãƒ€ãƒ¡+æ··ä¹±ä»˜ä¸ (ã‚¹ã‚­ãƒ«åå‹•:HP3%æ¶ˆè²»)' }
                    ] 
                },
                hiiro: { 
                    name: 'ãƒ’ã‚¤ãƒ­', job: 'é­”æ³•ä½¿ã„', icon: 'ğŸ§™', maxHp: 330, atk: 20, maxMp: 10, 
                    skills: [
                        { name: 'ã‚¹ã‚¿ãƒ¼ãƒ€ã‚¹ãƒˆ', desc: 'å›ºå®š65ãƒ€ãƒ¡ãƒ¼ã‚¸ + æˆåŠŸç‡80%ã§æ··ä¹±' },
                        { name: 'çœ ã‚‹', desc: 'HPå…¨å›å¾© + 2ã‚¿ãƒ¼ãƒ³ç¡çœ ' },
                        { name: 'ç—›ã¿åˆ†ã‘', desc: 'ãŠäº’ã„ã®HPã‚’å¹³å‡åŒ–ã™ã‚‹' },
                        { name: 'ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã‚¢ãƒ­ãƒ¼', desc: 'æ”»æ’ƒåŠ›ã®4.5å€ãƒ€ãƒ¡ãƒ¼ã‚¸ + 10ï½25%å›å¾©' },
                        { name: 'å¤±æ•—', desc: 'æš´èµ°ï¼ è‡ªåˆ†ã«æœ€å¤§HPã®25%ãƒ€ãƒ¡ãƒ¼ã‚¸' },
                        { name: 'ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¹ã‚¿ãƒ¼', desc: 'å‰²åˆãƒ€ãƒ¡ãƒ¼ã‚¸(èƒŒæ°´ã§å¨åŠ›UP) + ç¡çœ ' }
                    ] 
                }
            };

            const MONSTERS = [
                { name: 'ã‚¹ãƒ©ã‚¤ãƒ ', icon: 'ğŸ’§', hp: 80, atk: 18 },
                { name: 'ã‚´ãƒ–ãƒªãƒ³', icon: 'ğŸ‘º', hp: 140, atk: 28 },
                { name: 'ã‚ªãƒ¼ã‚¯', icon: 'ğŸ—', hp: 280, atk: 42 },
                { name: 'ãƒ‰ãƒ©ã‚´ãƒ³', icon: 'ğŸ²', hp: 550, atk: 60, hasEvolved: false }
            ];

            let gameStats = { totalDamageDealt: 0, totalDamageTaken: 0, totalTurns: 0 };
            let player = null, enemy = null, stage = 0, selectedKey = '';
            let chargeTurns = 0, superCharge = false, isProcessing = false, isAwakened = false;

            window.showDetails = function(key) {
                playSE('dice');
                selectedKey = key;
                const c = CHARACTERS[key];
                document.getElementById('char-detail').classList.remove('hidden');
                document.getElementById('detail-name').innerText = c.name;
                document.getElementById('detail-stats').innerText = `HP: ${c.maxHp} / ATK: ${c.atk} / MP: ${c.maxMp}`;
                const skillList = document.getElementById('detail-skills');
                skillList.innerHTML = '';
                c.skills.forEach((s, i) => {
                    const li = document.createElement('li');
                    li.className = "border-l-2 border-yellow-700 pl-2 py-0.5 text-left";
                    li.innerHTML = `<span class="text-yellow-500 font-bold">${i+1}. ${s.name}</span><br><span class="text-gray-400">${s.desc}</span>`;
                    skillList.appendChild(li);
                });
            };

            window.startGame = function() {
                playSE('victory');
                if (!selectedKey) return;
                const base = CHARACTERS[selectedKey];
                player = { ...base, hp: base.maxHp, mp: base.maxMp, status: [] };
                gameStats = { totalDamageDealt: 0, totalDamageTaken: 0, totalTurns: 0 };
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('battle-screen').classList.remove('hidden');
                document.getElementById('player-sprite').innerText = player.icon;
                initStage();
            };

            function initStage() {
                const m = MONSTERS[stage];
                enemy = { ...m, maxHp: m.hp, hp: m.hp, status: [] };
                player.mp = player.maxMp;
                chargeTurns = 0;
                isAwakened = false;
                document.getElementById('player-sprite').classList.remove('awakened');
                if (player.name !== 'ã‚·ãƒ¥ãƒ³ã‚¹ã‚±') superCharge = false;
                updateUI();
                log(`ã‚¨ãƒªã‚¢${stage + 1}: ${enemy.name}ãŒç¾ã‚ŒãŸï¼`);
            }

            function log(msg, color = 'white') {
                const div = document.createElement('div');
                div.style.color = color;
                div.innerText = "> " + msg;
                const box = document.getElementById('battle-log');
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            }

            function updateUI() {
                if(!player || !enemy) return;
                document.getElementById('player-name').innerText = player.name + (isAwakened ? " (è¦šé†’)" : "");
                document.getElementById('player-hp-text').innerText = `HP ${Math.ceil(player.hp)}/${player.maxHp}`;
                document.getElementById('player-hp-bar').style.width = `${(player.hp / player.maxHp) * 100}%`;
                document.getElementById('player-mp-text').innerText = `MP ${player.mp}/${player.maxMp}`;
                
                const pStatus = document.getElementById('player-status');
                pStatus.innerHTML = '';
                player.status.forEach(s => {
                    const span = document.createElement('span');
                    span.className = "px-1 bg-red-900 text-[8px] border border-red-500 rounded text-white";
                    span.innerText = s.type === 'poison' ? 'æ¯’' : s.type === 'confuse' ? 'æ··' : 'çœ ';
                    pStatus.appendChild(span);
                });

                document.getElementById('enemy-name').innerText = enemy.name;
                document.getElementById('enemy-sprite').innerText = enemy.icon;
                document.getElementById('enemy-hp-text').innerText = `HP ${Math.ceil(enemy.hp)}/${enemy.maxHp}`;
                document.getElementById('enemy-hp-bar').style.width = `${(enemy.hp / enemy.maxHp) * 100}%`;

                const eStatus = document.getElementById('enemy-status');
                eStatus.innerHTML = '';
                enemy.status.forEach(s => {
                    const span = document.createElement('span');
                    span.className = "px-1 bg-red-900 text-[8px] border border-red-500 rounded text-white";
                    span.innerText = s.type === 'poison' ? 'æ¯’' : s.type === 'confuse' ? 'æ··' : 'çœ ';
                    eStatus.appendChild(span);
                });

                const skillBtn = document.getElementById('skill-btn');
                if (player.mp < 1) {
                    skillBtn.classList.add('opacity-50', 'pointer-events-none');
                } else {
                    skillBtn.classList.remove('opacity-50', 'pointer-events-none');
                }
            }

            async function playCutin(skillName, colorClass = 'text-white') {
                const layer = document.getElementById('cutin-layer');
                const banner = document.getElementById('cutin-banner');
                const text = document.getElementById('cutin-text');
                text.innerText = skillName;
                text.className = `text-4xl font-black italic tracking-tighter text-glow ${colorClass}`;
                layer.classList.remove('opacity-0');
                banner.classList.add('cutin-active');
                await new Promise(r => setTimeout(r, 1500));
                banner.classList.remove('cutin-active');
                layer.classList.add('opacity-0');
            }

            async function tryEvolve() {
                if (enemy.name === 'ãƒ‰ãƒ©ã‚´ãƒ³' && !enemy.hasEvolved) {
                    isProcessing = true;
                    playSE('evolve');
                    log(`ãƒ‰ãƒ©ã‚´ãƒ³ã‚’å€’ã—ãŸ...ã—ã‹ã—ã€å‘¨å›²ãŒæ€¥ã«æš—ããªã‚‹ï¼`, '#6600cc');
                    await new Promise(r => setTimeout(r, 1500));
                    const flash = document.getElementById('flash-overlay');
                    flash.classList.add('flash-dark');
                    setTimeout(() => flash.classList.remove('flash-dark'), 1200);

                    enemy.name = 'ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆãƒ‰ãƒ©ã‚´ãƒ³';
                    enemy.icon = 'ğŸ”±ğŸ²';
                    enemy.maxHp = 999;
                    enemy.hp = 999;
                    enemy.atk = 85;
                    enemy.hasEvolved = true;
                    enemy.status = [];
                    log(`åº•çŸ¥ã‚Œã¬é—‡ã®ä¸­ã‹ã‚‰ã€Œã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆãƒ‰ãƒ©ã‚´ãƒ³ã€ãŒå†èª•ã—ãŸï¼`, '#ff0000');
                    await new Promise(r => setTimeout(r, 1000));

                    await playCutin('æ·±æ·µã®å’†å“®', 'text-purple-600');
                    const preDmg = Math.floor(player.maxHp * 0.25);
                    applyDamage(player, preDmg, false, 'player', true);
                    log(`æ¿€ã—ã„å’†å“®ãŒ${player.name}ã‚’è¥²ã†ï¼ ${preDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff4400');
                    await new Promise(r => setTimeout(r, 800));

                    isAwakened = true;
                    playSE('victory');
                    player.maxMp += 2;
                    player.mp = player.maxMp; 
                    player.atk = Math.floor(player.atk * 1.2);
                    document.getElementById('player-sprite').classList.add('awakened');
                    log(`çµ¶æœ›çš„ãªé—‡ã«æŠ—ã„ã€${player.name}ã¯è¦šé†’ã—ãŸï¼ï¼`, '#00ffff');
                    await new Promise(r => setTimeout(r, 1000));
                    updateUI();
                    isProcessing = false;
                    return true;
                }
                return false;
            }

            window.command = async function(type) {
                if (isProcessing) return;
                isProcessing = true;
                gameStats.totalTurns++;

                const canAct = checkStatusBeforeTurn(player);
                if (canAct.sleep) {
                    log(`${player.name}ã¯çœ ã£ã¦ã„ã‚‹...`);
                } else if (canAct.confuse && Math.random() < 0.5) {
                    log(`${player.name}ã¯æ··ä¹±ã—ã¦ã„ã‚‹ï¼`);
                    const selfDmg = Math.floor(player.atk * 0.5);
                    applyDamage(player, selfDmg, false, 'player', true);
                    log(`è‡ªåˆ†ã‚’æ”»æ’ƒã—ã¦${selfDmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ffaaaa');
                } else {
                    if (type === 'attack') {
                        playSE('attack');
                        const dmg = calculateDamage(player.atk);
                        applyDamage(enemy, dmg.value, dmg.isCrit, 'enemy');
                        log(`${player.name}ã®æ”»æ’ƒï¼ ${dmg.value}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ ${dmg.isCrit ? 'ä¼šå¿ƒã®ä¸€æ’ƒï¼' : ''}`);
                    } else if (type === 'heal') {
                        playSE('heal');
                        const healAmt = Math.floor(player.maxHp * (player.name === 'ãƒ’ã‚¤ãƒ­' ? 0.6 : 0.4));
                        player.hp = Math.min(player.maxHp, player.hp + healAmt);
                        log(`${player.name}ã¯ç¥ˆã£ãŸï¼ HPãŒ${healAmt}å›å¾©ï¼`, '#aaffaa');
                    } else if (type === 'skill') {
                        player.mp -= 1;
                        await rollDiceAndExecuteSkill();
                        if (player.name === 'ã‚·ãƒ¥ãƒ³ã‚¹ã‚±') {
                            const recoil = Math.floor(player.maxHp * 0.03);
                            applyDamage(player, recoil, false, 'player', true);
                            log(`ã‚¹ã‚­ãƒ«ã®åå‹•ã§HPãŒ${recoil}æ¸›å°‘ï¼`, '#ffaaaa');
                        }
                    }
                }

                updateUI();
                if (enemy.hp <= 0) {
                    const evolved = await tryEvolve();
                    if (evolved) return; 
                    await new Promise(r => setTimeout(r, 800));
                    showResult(true);
                    isProcessing = false;
                    return;
                }
                if (player.hp <= 0) {
                    showResult(false);
                    isProcessing = false;
                    return;
                }

                await new Promise(r => setTimeout(r, 800));
                
                if (enemy.hp > 0) {
                    const enemyCanAct = checkStatusBeforeTurn(enemy);
                    if (!enemyCanAct.sleep && (!enemyCanAct.confuse || Math.random() >= 0.5)) {
                        playSE('hit');
                        const isDesperate = Math.random() < 0.10;
                        let eDmg = Math.floor(enemy.atk * (0.9 + Math.random() * 0.4));
                        if (isDesperate) eDmg *= 2;
                        const avoided = applyDamage(player, eDmg, isDesperate, 'player');
                        if (avoided) {
                            log(`${enemy.name}ã®æ”»æ’ƒã‚’ã‹ã‚ã—ãŸï¼`, '#00ffff');
                        } else {
                            log(`${enemy.name}ã®æ”»æ’ƒï¼ ${eDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ffaaaa');
                        }
                    }
                }

                updateUI();
                applyPoison(player);
                applyPoison(enemy);
                
                if (player.hp <= 0) {
                    showResult(false);
                } else if (enemy.hp <= 0) {
                    const evolved = await tryEvolve();
                    if (!evolved) showResult(true);
                }
                isProcessing = false;
            };

            function calculateDamage(baseAtk, multiplier = 1, critChance = 0.12) {
                let isCrit = Math.random() < critChance || superCharge || chargeTurns > 0;
                let dmg = baseAtk * multiplier;
                if (isCrit) {
                    dmg *= 3;
                    if (chargeTurns > 0) chargeTurns--;
                }
                dmg = Math.floor(dmg * (0.9 + Math.random() * 0.2));
                return { value: dmg, isCrit };
            }

            function applyDamage(target, amount, isCrit, targetType, mustHit = false) {
                if (!mustHit && Math.random() < 0.05) {
                    return true;
                }
                target.hp = Math.max(0, target.hp - amount);
                if (targetType === 'enemy') gameStats.totalDamageDealt += amount;
                else gameStats.totalDamageTaken += amount;
                const container = targetType === 'player' ? document.getElementById('player-sprite-container') : document.getElementById('enemy-sprite');
                container.classList.add('shake');
                setTimeout(() => container.classList.remove('shake'), 500);
                return false;
            }

            function setStatus(target, type, turns = 99, probability = 1.0) {
                if (target.status.some(s => s.type === type)) return false;
                if (Math.random() <= probability) {
                    target.status.push({ type, turns });
                    return true;
                }
                return false;
            }

            function checkStatusBeforeTurn(unit) {
                let res = { sleep: false, confuse: false };
                unit.status = unit.status.filter(s => {
                    if (s.type === 'sleep') {
                        s.turns--;
                        if (s.turns <= 0 || Math.random() < 0.3) return false;
                        res.sleep = true;
                        return true;
                    }
                    if (s.type === 'confuse') {
                        if (Math.random() < 0.2) return false;
                        res.confuse = true;
                    }
                    return true;
                });
                return res;
            }

            function applyPoison(unit) {
                if (unit.status.some(s => s.type === 'poison')) {
                    const dmg = Math.floor(unit.maxHp * 0.1);
                    applyDamage(unit, dmg, false, unit === player ? 'player' : 'enemy', true);
                    log(`${unit.name}ã¯æ¯’ã§${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff5555');
                }
            }

            async function rollDiceAndExecuteSkill() {
                const overlay = document.getElementById('dice-overlay');
                const anim = document.getElementById('dice-anim');
                const resName = document.getElementById('dice-result-name');
                overlay.classList.remove('hidden');
                for(let i=0; i<10; i++) {
                    playSE('dice');
                    anim.innerText = Math.floor(Math.random()*6)+1;
                    await new Promise(r => setTimeout(r, 60));
                }
                let roll = Math.floor(Math.random() * 6) + 1;
                anim.innerText = roll;
                const skill = player.skills[roll-1];
                resName.innerText = skill.name;
                await new Promise(r => setTimeout(r, 800));
                overlay.classList.add('hidden');

                playSE('skill');
                log(`${player.name}ã®ã‚¹ã‚­ãƒ«ï¼š${skill.name}ï¼`, '#55aaff');
                const boost = isAwakened ? 1.5 : 1.0;

                if (player.name === 'ã‚¢ãƒ¦ãƒ ') {
                    if (roll === 1) {
                        const isWeak = (enemy.hp <= enemy.maxHp * 0.4);
                        let dmgValue = isWeak ? 777 : calculateDamage(player.atk, 1.8 * boost, 1).value;
                        applyDamage(enemy, dmgValue, true, 'enemy', isWeak);
                    } else if (roll === 2) { chargeTurns = 2; }
                    else if (roll === 3) {
                        let dmg = calculateDamage(player.atk, 1.2 * boost, 1).value + Math.floor(enemy.maxHp * 0.1 * boost);
                        applyDamage(enemy, dmg, true, 'enemy');
                    } else if (roll === 5 || roll === 6) {
                        let dmg = calculateDamage(player.atk, 1 * boost, roll===6 ? 1 : 0.12).value;
                        applyDamage(enemy, dmg, roll===6, 'enemy');
                        player.hp = Math.min(player.maxHp, player.hp + dmg);
                    }
                } else if (player.name === 'ãƒ’ã‚«ãƒ«') {
                    if (roll === 2) { chargeTurns = 2; }
                    else if (roll === 3 || roll === 6) { setStatus(enemy, 'poison', 99, 0.8); }
                    else if (roll === 4 || roll === 5) {
                        for(let i=0; i<(isAwakened ? 8 : 5); i++) {
                            playSE('attack');
                            applyDamage(enemy, Math.floor(player.atk * 0.35), false, 'enemy');
                            updateUI();
                            await new Promise(r => setTimeout(r, 200));
                            if (enemy.hp <= 0) break;
                        }
                    }
                } else if (player.name === 'ã‚·ãƒ¥ãƒ³ã‚¹ã‚±') {
                    if (roll === 1) { applyDamage(enemy, calculateDamage(player.atk, 2.5 * boost).value, true, 'enemy'); }
                    else if (roll === 2) { chargeTurns = 2; }
                    else if (roll === 3) { superCharge = true; }
                    else if (roll === 5) { applyDamage(enemy, Math.floor(enemy.hp * (isAwakened ? 0.9 : 0.7)), false, 'enemy'); }
                    else if (roll === 6) { applyDamage(enemy, player.atk, false, 'enemy'); setStatus(enemy, 'confuse', 99, 0.7); }
                } else if (player.name === 'ãƒ’ã‚¤ãƒ­') {
                    if (roll === 1) { applyDamage(enemy, Math.floor(65 * boost), false, 'enemy'); setStatus(enemy, 'confuse', 99, 0.8); }
                    else if (roll === 2) { player.hp = player.maxHp; setStatus(player, 'sleep', isAwakened ? 1 : 2, 1.0); }
                    else if (roll === 3) { let avg = Math.floor((player.hp + enemy.hp) / 2); player.hp = Math.min(player.maxHp, avg); enemy.hp = Math.min(enemy.maxHp, avg); }
                    else if (roll === 4) { let dmg = calculateDamage(player.atk, 4.5 * boost).value; applyDamage(enemy, dmg, false, 'enemy'); player.hp = Math.min(player.maxHp, player.hp + Math.floor(dmg*0.2)); }
                    else if (roll === 5) { applyDamage(player, Math.floor(player.maxHp * 0.25), false, 'player', true); }
                    else if (roll === 6) { applyDamage(enemy, Math.floor(enemy.hp * 0.4), false, 'enemy'); setStatus(enemy, 'sleep', 3, 0.9); }
                }
                updateUI();
            }

            function showResult(victory) {
                document.getElementById('battle-screen').classList.add('hidden');
                document.getElementById('result-screen').classList.remove('hidden');
                const title = document.getElementById('result-title');
                const msg = document.getElementById('result-message');
                const next = document.getElementById('next-btn');
                const restart = document.getElementById('restart-btn');

                if (victory) {
                    playSE('victory');
                    title.innerText = "âœ¨ VICTORY âœ¨";
                    if (stage >= MONSTERS.length - 1 && enemy.hasEvolved) {
                        title.innerText = "ğŸŒˆ ALL CLEAR ğŸŒˆ";
                        document.getElementById('adventure-stats').classList.remove('hidden');
                        document.getElementById('stat-hero').innerText = player.name;
                        document.getElementById('stat-dmg-dealt').innerText = gameStats.totalDamageDealt;
                        document.getElementById('stat-dmg-taken').innerText = gameStats.totalDamageTaken;
                        document.getElementById('stat-turns').innerText = gameStats.totalTurns;
                        next.classList.add('hidden');
                        restart.classList.remove('hidden');
                    } else {
                        next.classList.remove('hidden');
                        restart.classList.add('hidden');
                    }
                } else {
                    playSE('evolve');
                    title.innerText = "GAME OVER";
                    msg.innerText = "å†’é™ºã¯ã“ã“ã§çµ‚ã‚ã£ã¦ã—ã¾ã£ãŸ...";
                    next.classList.add('hidden');
                    restart.classList.remove('hidden');
                }
            }

            window.nextStage = function() {
                stage++;
                document.getElementById('result-screen').classList.add('hidden');
                document.getElementById('battle-screen').classList.remove('hidden');
                initStage();
            };
        })();
    </script>
</body>
</html>
