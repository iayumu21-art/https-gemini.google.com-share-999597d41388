<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã•ã„ã“ã‚ã‚¸ãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        body {
            font-family: 'DotGothic16', sans-serif;
            background-color: #1a1a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            margin: 0;
        }
        #app {
            height: 100vh;
            max-height: 100vh;
        }
        .battle-log {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(0,0,0,0.8);
            min-height: 60px;
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .dice {
            display: inline-block;
            width: 60px;
            height: 60px;
            line-height: 60px;
            text-align: center;
            background: white;
            color: black;
            border-radius: 8px;
            font-size: 32px;
            font-weight: bold;
        }
        @keyframes aura-pulse {
            0% { filter: drop-shadow(0 0 5px #fff); transform: scale(1); }
            50% { filter: drop-shadow(0 0 15px #00ffff); transform: scale(1.1); }
            100% { filter: drop-shadow(0 0 5px #fff); transform: scale(1); }
        }
        .awakened {
            animation: aura-pulse 1.5s infinite ease-in-out;
            color: #00ffff !important;
        }
        @keyframes cutin-in {
            0% { transform: translateX(-100%) skewX(-20deg); opacity: 0; }
            20% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            80% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            100% { transform: translateX(100%) skewX(-20deg); opacity: 0; }
        }
        .cutin-active {
            animation: cutin-in 1.5s ease-in-out forwards;
        }
        .text-glow {
            text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px currentColor;
        }
        .flash-dark {
            animation: flash-dark-anim 1.2s ease-out;
        }
        @keyframes flash-dark-anim {
            0% { background-color: #000; opacity: 1; }
            50% { background-color: #200040; opacity: 0.8; }
            100% { background-color: transparent; opacity: 0; }
        }
        .victory-anim {
            animation: victory-zoom 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes victory-zoom {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .awakened-skill {
            color: #00ffff;
            text-shadow: 0 0 5px #008888;
        }
    </style>
</head>
<body class="flex items-center justify-center">

    <div id="app" class="relative w-full max-w-md bg-gray-900 p-2 sm:p-4 rounded-none sm:rounded-xl shadow-2xl flex flex-col border-4 border-gray-700">
        <!-- Start Screen -->
        <div id="start-screen" class="flex-grow flex flex-col items-center justify-center overflow-y-auto">
            <h1 class="text-2xl font-bold mb-4 text-yellow-500 text-center text-glow">ã•ã„ã“ã‚ã‚¸ãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ</h1>
            <p class="mb-4 text-sm text-gray-300">å†’é™ºè€…ã‚’é¸ã‚“ã§ãã ã•ã„</p>
            
            <div class="grid grid-cols-2 gap-2 w-full mb-4">
                <button onclick="window.showDetails('ayumu')" class="bg-blue-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">âš”ï¸</div>
                    <div class="text-xs font-bold">ã‚¢ãƒ¦ãƒ  (å‹‡è€…)</div>
                </button>
                <button onclick="window.showDetails('hikaru')" class="bg-green-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ¥·</div>
                    <div class="text-xs font-bold">ãƒ’ã‚«ãƒ« (å¿è€…)</div>
                </button>
                <button onclick="window.showDetails('shunsuke')" class="bg-red-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ›¡ï¸</div>
                    <div class="text-xs font-bold">ã‚·ãƒ¥ãƒ³ã‚¹ã‚± (æˆ¦å£«)</div>
                </button>
                <button onclick="window.showDetails('hiiro')" class="bg-purple-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ§™</div>
                    <div class="text-xs font-bold">ãƒ’ã‚¤ãƒ­ (é­”æ³•ä½¿ã„)</div>
                </button>
            </div>

            <div id="char-detail" class="hidden w-full bg-black p-3 border-2 border-yellow-500 rounded mb-2">
                <h2 id="detail-name" class="text-lg font-bold text-yellow-400"></h2>
                <div id="detail-stats" class="text-xs mb-2 text-gray-300 border-b border-gray-700 pb-2"></div>
                <div class="text-[10px] text-gray-400 font-bold mt-2 mb-1">ã€ã‚¹ã‚­ãƒ«ãƒªã‚¹ãƒˆ (ãƒ€ã‚¤ã‚¹ã®ç›®)ã€‘</div>
                <ul id="detail-skills" class="text-[9px] list-none mb-3 grid grid-cols-1 gap-1 text-gray-200"></ul>
                <button onclick="window.startGame()" class="w-full bg-yellow-600 hover:bg-yellow-500 py-2 rounded font-bold text-white text-sm">å†’é™ºã«å‡ºã‚‹</button>
            </div>
        </div>

        <!-- Battle Screen -->
        <div id="battle-screen" class="hidden h-full flex flex-col relative overflow-hidden">
            <div id="flash-overlay" class="absolute inset-0 z-50 pointer-events-none"></div>

            <!-- ã‚«ãƒƒãƒˆã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
            <div id="cutin-layer" class="pointer-events-none absolute inset-0 z-40 flex items-center justify-center opacity-0 transition-opacity duration-300">
                <div id="cutin-banner" class="w-[150%] h-24 bg-gradient-to-r from-transparent via-white/20 to-transparent border-y-4 border-white flex items-center justify-center">
                    <span id="cutin-text" class="text-4xl font-black italic tracking-tighter text-glow"></span>
                </div>
            </div>

            <!-- Enemy Area -->
            <div class="relative flex flex-col h-40 bg-gray-800 rounded-t-lg border-b-2 border-gray-700 p-2">
                <div class="w-full mb-auto">
                    <div class="flex justify-between text-xs text-white mb-1">
                        <span id="enemy-name" class="font-bold drop-shadow-lg text-white"></span>
                        <span id="enemy-hp-text" class="font-bold"></span>
                    </div>
                    <div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden border border-gray-600">
                        <div id="enemy-hp-bar" class="bg-red-500 h-full transition-all duration-300"></div>
                    </div>
                    <div id="enemy-status" class="flex mt-1 gap-1 min-h-[14px]"></div>
                </div>
                <div class="flex items-center justify-center flex-grow">
                    <div id="enemy-sprite" class="text-6xl transition-all duration-500 drop-shadow-lg">ğŸ‘¾</div>
                </div>
            </div>

            <!-- Player Area -->
            <div class="p-2 bg-gray-900 border-x-2 border-gray-700 flex flex-col items-center">
                <div id="player-sprite-container" class="mb-1 transition-transform">
                    <div id="player-sprite" class="text-4xl drop-shadow-md"></div>
                </div>
                <div class="w-full">
                    <div class="flex justify-between text-xs mb-1">
                        <span id="player-name" class="font-bold text-blue-400"></span>
                        <span id="player-hp-text"></span>
                    </div>
                    <div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden mb-1 border border-gray-600">
                        <div id="player-hp-bar" class="bg-green-500 h-full transition-all duration-300"></div>
                    </div>
                    <div class="flex justify-between text-[10px] text-gray-300">
                        <span id="player-mp-text"></span>
                        <div id="player-status" class="flex gap-1 min-h-[12px]"></div>
                    </div>
                </div>
            </div>

            <div id="battle-log" class="battle-log p-2 text-[11px] border-2 border-gray-700 bg-black font-mono leading-tight">
                <div>å†’é™ºãŒå§‹ã¾ã£ãŸï¼</div>
            </div>

            <div id="action-panel" class="grid grid-cols-2 gap-1 p-2 bg-gray-800 rounded-b-lg border-t-2 border-gray-700">
                <button onclick="window.command('attack')" class="bg-red-700 hover:bg-red-600 py-2 rounded text-white font-bold text-sm border-b-2 border-red-900">æ”»æ’ƒ</button>
                <button onclick="window.command('heal')" class="bg-emerald-700 hover:bg-emerald-600 py-2 rounded text-white font-bold text-sm border-b-2 border-emerald-900">å›å¾©</button>
                <button id="skill-btn" onclick="window.command('skill')" class="bg-blue-700 hover:bg-blue-600 py-2 rounded col-span-2 text-white font-bold text-sm border-b-2 border-blue-900">ã‚¹ã‚­ãƒ« (MP 1)</button>
            </div>
        </div>

        <!-- Result Screen -->
        <div id="result-screen" class="hidden flex-grow flex flex-col items-center justify-center text-center z-50 overflow-y-auto pt-4 pb-4">
            <h2 id="result-title" class="text-3xl font-bold mb-4 drop-shadow-lg victory-anim"></h2>
            <div id="adventure-stats" class="w-full px-4 mb-4 hidden">
                <div class="bg-black/60 border-2 border-yellow-600 rounded-lg p-3 text-left">
                    <h3 class="text-yellow-400 font-bold border-b border-yellow-800 mb-2 pb-1 text-center">âœ¨ å†’é™ºã®è¨˜éŒ² âœ¨</h3>
                    <div class="grid grid-cols-1 gap-2 text-sm">
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">è·æ¥­:</span>
                            <span id="stat-hero" class="text-white font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">ä¸ãˆãŸç·ãƒ€ãƒ¡ãƒ¼ã‚¸:</span>
                            <span id="stat-dmg-dealt" class="text-red-400 font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">å—ã‘ãŸç·ãƒ€ãƒ¡ãƒ¼ã‚¸:</span>
                            <span id="stat-dmg-taken" class="text-orange-400 font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">ã‚¿ãƒ¼ãƒ³æ•°:</span>
                            <span id="stat-turns" class="text-blue-400 font-bold"></span>
                        </div>
                    </div>
                </div>
            </div>
            <div id="result-message" class="text-sm text-white px-4 mb-4 leading-relaxed"></div>
            <div id="thanks-message" class="hidden text-lg font-bold text-yellow-500 mb-6 animate-pulse">ãƒ—ãƒ¬ã‚¤ã—ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ï¼</div>
            <div class="flex flex-col gap-2 w-full px-8">
                <button id="next-btn" onclick="window.nextStage()" class="bg-yellow-600 hover:bg-yellow-500 py-3 rounded font-bold text-white text-sm shadow-lg">æ¬¡ã®ã‚¨ãƒªã‚¢ã¸</button>
                <button id="restart-btn" onclick="location.reload()" class="hidden bg-gray-600 hover:bg-gray-500 py-3 rounded font-bold text-white text-sm">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
            </div>
        </div>

        <!-- Dice Overlay -->
        <div id="dice-overlay" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div class="text-center p-6 bg-gray-900 rounded-2xl border-2 border-yellow-500 shadow-2xl">
                <div id="dice-anim" class="dice shadow-lg">?</div>
                <div id="dice-result-name" class="mt-4 text-xl font-bold text-yellow-400"></div>
            </div>
        </div>
    </div>

    <script>
        (function() {
            // --- Sound Engine ---
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            function playSE(type) {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const now = audioCtx.currentTime;

                const createGrumble = (freq, duration, gainVal) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const lfo = audioCtx.createOscillator();
                    const lfoGain = audioCtx.createGain();

                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(freq, now);
                    osc.frequency.exponentialRampToValueAtTime(freq / 2.5, now + duration);

                    lfo.type = 'sine';
                    lfo.frequency.setValueAtTime(15, now); 
                    lfoGain.gain.setValueAtTime(freq * 0.2, now);
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);

                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(gainVal, now + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                    lfo.start(now);
                    osc.start(now);
                    lfo.stop(now + duration);
                    osc.stop(now + duration);
                };

                switch(type) {
                    case 'attack': {
                        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                        osc.type = 'square'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
                        gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.1); break;
                    }
                    case 'hit': {
                        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(220, now); osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.1); break;
                    }
                    case 'critical': {
                        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(110, now); osc.frequency.exponentialRampToValueAtTime(880, now + 0.15);
                        gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.15);
                        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.15); break;
                    }
                    case 'bad_hit': {
                        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(60, now); osc.frequency.linearRampToValueAtTime(40, now + 0.2);
                        gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.2);
                        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.2); break;
                    }
                    case 'heal': {
                        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                        osc.type = 'sine'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(880, now + 0.3);
                        gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.3); break;
                    }
                    case 'dice': {
                        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                        osc.type = 'triangle'; osc.frequency.setValueAtTime(880, now); gain.gain.setValueAtTime(0.05, now);
                        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.05); break;
                    }
                    case 'skill': {
                        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                        osc.type = 'square'; osc.frequency.setValueAtTime(110, now); osc.frequency.exponentialRampToValueAtTime(660, now + 0.4);
                        gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.4); break;
                    }
                    case 'cutin': [880, 1100, 1320].forEach((f, i) => { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'sine'; o.connect(g); g.connect(audioCtx.destination); o.frequency.setValueAtTime(f, now + i * 0.05); g.gain.setValueAtTime(0.1, now + i * 0.05); g.gain.linearRampToValueAtTime(0, now + i * 0.05 + 0.5); o.start(now + i * 0.05); o.stop(now + i * 0.05 + 0.5); }); break;
                    case 'victory': [440, 554, 659].forEach((f, i) => { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'square'; o.connect(g); g.connect(audioCtx.destination); o.frequency.setValueAtTime(f, now + i * 0.1); g.gain.setValueAtTime(0.05, now + i * 0.1); g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.4); o.start(now + i * 0.1); o.stop(now + i * 0.1 + 0.4); }); break;
                    case 'evolve': { createGrumble(80, 2.0, 0.4); createGrumble(60, 2.5, 0.3); break; }
                    case 'dark_roar': { createGrumble(55, 1.5, 0.5); createGrumble(73, 1.2, 0.4); createGrumble(38, 1.8, 0.3); const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(40, now + 1.5); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 1.5); break; }
                }
            }

            const CHARACTERS = {
                ayumu: { 
                    name: 'ã‚¢ãƒ¦ãƒ ', job: 'å‹‡è€…', icon: 'âš”ï¸', maxHp: 400, atk: 30, maxMp: 5, 
                    skills: [
                        { name: 'å¿…æ®ºã®ä¸€æ’ƒ', desc: 'å¼±ã£ã¦ã„ã‚‹æ•µã«777 / é€šå¸¸ã¯å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸' },
                        { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®ç‰©ç†æ”»æ’ƒãŒ3å€' },
                        { name: 'å¸Œæœ›ã®ä¸€æŒ¯ã‚Š', desc: 'ä¼šå¿ƒã®ä¸€æ’ƒ + æ•µæœ€å¤§HPã®10%åŠ ç®—' },
                        { name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„' },
                        { name: 'ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒ‰', desc: 'é€šå¸¸ãƒ€ãƒ¡ãƒ¼ã‚¸ + ä¸ãˆãŸåˆ†å›å¾©' },
                        { name: 'ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒ‰æ”¹', desc: 'å¿…ä¸­ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸ + ä¸ãˆãŸåˆ†å›å¾©' }
                    ] 
                },
                hikaru: { 
                    name: 'ãƒ’ã‚«ãƒ«', job: 'å¿è€…', icon: 'ğŸ¥·', maxHp: 280, atk: 45, maxMp: 5, 
                    skills: [
                        { name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„' },
                        { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®æ”»æ’ƒãŒ3å€' },
                        { name: 'æ¯’çŸ¢', desc: 'æˆåŠŸç‡80%:æ•µã‚’æ¯’çŠ¶æ…‹ã«ã™ã‚‹' },
                        { name: 'æ‰‹è£å‰£', desc: 'å¨åŠ›35%Ã—5å›é€£ç¶šæ”»æ’ƒ' },
                        { name: 'æ‰‹è£å‰£', desc: 'å¨åŠ›35%Ã—5å›é€£ç¶šæ”»æ’ƒ' },
                        { name: 'æ¯’çŸ¢', desc: 'æˆåŠŸç‡80%:æ•µã‚’æ¯’çŠ¶æ…‹ã«ã™ã‚‹' }
                    ] 
                },
                shunsuke: { 
                    name: 'ã‚·ãƒ¥ãƒ³ã‚¹ã‚±', job: 'æˆ¦å£«', icon: 'ğŸ›¡ï¸', maxHp: 520, atk: 35, maxMp: 3, 
                    skills: [
                        { name: 'å¤§åœ°æ–¬', desc: 'æ”»æ’ƒåŠ›ã®2.5å€ãƒ€ãƒ¡ (ã‚¹ã‚­ãƒ«åå‹•:HP3%æ¶ˆè²»)' },
                        { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®æ”»æ’ƒãŒ3å€ (æ¬¡å›ã®è¢«ãƒ€ãƒ¡è»½æ¸›)' },
                        { name: 'è¶…ãŸã‚ã‚‹', desc: 'æ°¸ç¶šçš„ã«ä¼šå¿ƒç‡UP (è¢«ãƒ€ãƒ¡è»½æ¸›)' },
                        { name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„ (ã‚¹ã‚­ãƒ«åå‹•:HP3%æ¶ˆè²»)' },
                        { name: 'æ­»ã®ä¸€æŒ¯ã‚Š', desc: 'æ•µHPã®70%ã‚’å‰Šã‚‹ (ã‚¹ã‚­ãƒ«åå‹•:HP3%æ¶ˆè²»)' },
                        { name: 'ã“ã‚“ã‚‰ã‚“æ”»æ’ƒ', desc: 'ãƒ€ãƒ¡+æ··ä¹±ä»˜ä¸ (ã‚¹ã‚­ãƒ«åå‹•:HP3%æ¶ˆè²»)' }
                    ] 
                },
                hiiro: { 
                    name: 'ãƒ’ã‚¤ãƒ­', job: 'é­”æ³•ä½¿ã„', icon: 'ğŸ§™', maxHp: 330, atk: 20, maxMp: 10, 
                    skills: [
                        { name: 'ã‚¹ã‚¿ãƒ¼ãƒ€ã‚¹ãƒˆ', desc: 'å›ºå®š65ãƒ€ãƒ¡ãƒ¼ã‚¸ + æˆåŠŸç‡80%ã§æ··ä¹±' },
                        { name: 'çœ ã‚‹', desc: 'HPå…¨å›å¾© + 2ã‚¿ãƒ¼ãƒ³ç¡çœ ' },
                        { name: 'ç—›ã¿åˆ†ã‘', desc: 'ãŠäº’ã„ã®æœ€å¤§HPæ¯”ç‡ã‚’å¹³å‡åŒ–ã™ã‚‹' },
                        { name: 'ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã‚¢ãƒ­ãƒ¼', desc: 'æ”»æ’ƒåŠ›ã®4.5å€ãƒ€ãƒ¡ãƒ¼ã‚¸ + 10ï½25%å›å¾©' },
                        { name: 'å¤±æ•—', desc: 'æš´èµ°ï¼ è‡ªåˆ†ã«æœ€å¤§HPã®25%ãƒ€ãƒ¡ãƒ¼ã‚¸' },
                        { name: 'ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¹ã‚¿ãƒ¼', desc: 'å‰²åˆãƒ€ãƒ¡ãƒ¼ã‚¸(è¦šé†’ã§å¼·åŒ–) + ç¡çœ ' }
                    ] 
                }
            };

            const MONSTERS = [
                { name: 'ã‚¹ãƒ©ã‚¤ãƒ ', icon: 'ğŸ’§', hp: 80, atk: 18 },
                { name: 'ã‚´ãƒ–ãƒªãƒ³', icon: 'ğŸ‘º', hp: 140, atk: 28 },
                { name: 'ã‚ªãƒ¼ã‚¯', icon: 'ğŸ—', hp: 280, atk: 42 },
                { name: 'ãƒ‰ãƒ©ã‚´ãƒ³', icon: 'ğŸ²', hp: 550, atk: 60, hasEvolved: false }
            ];

            let player, enemy, stage = 0, selectedKey = '';
            let gameStats = { heroName: '', heroJob: '', totalDamageDealt: 0, totalDamageTaken: 0, totalTurns: 0 };
            let chargeTurns = 0, superCharge = false, isProcessing = false, isAwakened = false;

            window.showDetails = function(key) {
                playSE('dice');
                selectedKey = key;
                const c = CHARACTERS[key];
                document.getElementById('char-detail').classList.remove('hidden');
                document.getElementById('detail-name').innerText = `${c.name} (${c.job})`;
                document.getElementById('detail-stats').innerText = `HP: ${c.maxHp} / ATK: ${c.atk} / MP: ${c.maxMp}`;
                const skillList = document.getElementById('detail-skills');
                skillList.innerHTML = '';
                c.skills.forEach((s, i) => {
                    const li = document.createElement('li');
                    li.className = "border-l-2 border-yellow-700 pl-2 py-0.5 text-left";
                    li.innerHTML = `<span class="text-yellow-500 font-bold">${i+1}. ${s.name}</span><br><span class="text-gray-400">${s.desc}</span>`;
                    skillList.appendChild(li);
                });
            };

            window.startGame = function() {
                playSE('victory');
                if (!selectedKey) return;
                const base = CHARACTERS[selectedKey];
                player = { ...base, hp: base.maxHp, mp: base.maxMp, status: [] };
                gameStats = { heroName: base.name, heroJob: base.job, totalDamageDealt: 0, totalDamageTaken: 0, totalTurns: 0 };
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('battle-screen').classList.remove('hidden');
                document.getElementById('player-sprite').innerText = player.icon;
                initStage();
            };

            function initStage() {
                const m = MONSTERS[stage];
                enemy = { ...m, maxHp: m.hp, hp: m.hp, status: [] };
                player.mp = player.maxMp;
                chargeTurns = 0;
                isAwakened = false;
                document.getElementById('player-sprite').classList.remove('awakened');
                if (player.job !== 'æˆ¦å£«') superCharge = false;
                updateUI();
                log(`ã‚¨ãƒªã‚¢${stage + 1}: ${enemy.name}ãŒç¾ã‚ŒãŸï¼`);
            }

            function log(msg, color = 'white') {
                const div = document.createElement('div');
                div.style.color = color;
                div.innerText = "> " + msg;
                const box = document.getElementById('battle-log');
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            }

            function updateUI() {
                if(!player || !enemy) return;
                const nameEl = document.getElementById('player-name');
                nameEl.innerText = `${player.name} (${player.job})${isAwakened ? " (è¦šé†’)" : ""}`;
                if(isAwakened) nameEl.classList.add('awakened-skill'); else nameEl.classList.remove('awakened-skill');
                
                document.getElementById('player-hp-text').innerText = `HP ${Math.ceil(player.hp)}/${player.maxHp}`;
                document.getElementById('player-hp-bar').style.width = `${(player.hp / player.maxHp) * 100}%`;
                document.getElementById('player-mp-text').innerText = `MP ${player.mp}/${player.maxMp}`;
                document.getElementById('enemy-name').innerText = enemy.name;
                document.getElementById('enemy-sprite').innerText = enemy.icon;
                document.getElementById('enemy-hp-text').innerText = `HP ${Math.ceil(enemy.hp)}/${enemy.maxHp}`;
                document.getElementById('enemy-hp-bar').style.width = `${(enemy.hp / enemy.maxHp) * 100}%`;

                const pStatus = document.getElementById('player-status');
                pStatus.innerHTML = '';
                player.status.forEach(s => {
                    const span = document.createElement('span');
                    span.className = "px-1 bg-red-900 text-[8px] border border-red-500 rounded text-white";
                    span.innerText = s.type === 'poison' ? 'æ¯’' : s.type === 'confuse' ? 'æ··' : 'çœ ';
                    pStatus.appendChild(span);
                });

                const eStatus = document.getElementById('enemy-status');
                eStatus.innerHTML = '';
                enemy.status.forEach(s => {
                    const span = document.createElement('span');
                    span.className = "px-1 bg-red-900 text-[8px] border border-red-500 rounded text-white";
                    span.innerText = s.type === 'poison' ? 'æ¯’' : s.type === 'confuse' ? 'æ··' : 'çœ ';
                    eStatus.appendChild(span);
                });

                const skillBtn = document.getElementById('skill-btn');
                if (player.mp < 1) {
                    skillBtn.classList.add('opacity-50', 'pointer-events-none');
                } else {
                    skillBtn.classList.remove('opacity-50', 'pointer-events-none');
                }
            }

            async function playCutin(skillName, colorClass = 'text-white') {
                const layer = document.getElementById('cutin-layer');
                const banner = document.getElementById('cutin-banner');
                const text = document.getElementById('cutin-text');
                text.innerText = skillName;
                text.className = `text-4xl font-black italic tracking-tighter text-glow ${colorClass}`;
                layer.classList.remove('opacity-0');
                banner.classList.add('cutin-active');
                await new Promise(r => setTimeout(r, 1500));
                banner.classList.remove('cutin-active');
                layer.classList.add('opacity-0');
            }

            async function tryEvolve() {
                if (enemy.name === 'ãƒ‰ãƒ©ã‚´ãƒ³' && !enemy.hasEvolved) {
                    isProcessing = true;
                    playSE('evolve');
                    log(`ãƒ‰ãƒ©ã‚´ãƒ³ã‚’å€’ã—ãŸ...ã—ã‹ã—ã€å‘¨å›²ãŒæ€¥ã«æš—ããªã‚‹ï¼`, '#6600cc');
                    await new Promise(r => setTimeout(r, 1500));
                    const flash = document.getElementById('flash-overlay');
                    flash.classList.add('flash-dark');
                    setTimeout(() => flash.classList.remove('flash-dark'), 1200);

                    enemy.name = 'ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆãƒ‰ãƒ©ã‚´ãƒ³';
                    enemy.icon = 'ğŸ”±ğŸ²';
                    enemy.maxHp = 999;
                    enemy.hp = 999;
                    enemy.atk = 85;
                    enemy.hasEvolved = true;
                    enemy.status = [];
                    log(`åº•çŸ¥ã‚Œã¬é—‡ã®ä¸­ã‹ã‚‰ã€Œã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆãƒ‰ãƒ©ã‚´ãƒ³ã€ãŒå†èª•ã—ãŸï¼`, '#ff0000');
                    await new Promise(r => setTimeout(r, 1000));

                    playSE('dark_roar');
                    await playCutin('æ·±æ·µã®å’†å“®', 'text-purple-600');
                    const preDmg = Math.floor(player.maxHp * 0.25);
                    applyDamage(player, preDmg, false, 'player', true);
                    log(`æ¿€ã—ã„å’†å“®ãŒ${player.name}ã‚’è¥²ã†ï¼ ${preDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff4400');
                    
                    isAwakened = true;
                    playSE('victory');
                    player.maxMp += 2;
                    player.mp = player.maxMp; 
                    player.atk = Math.floor(player.atk * 1.3);
                    document.getElementById('player-sprite').classList.add('awakened');
                    log(`çµ¶æœ›çš„ãªé—‡ã«æŠ—ã„ã€${player.name}ã®å…¨ã‚¹ã‚­ãƒ«ãŒè¦šé†’ã—ãŸï¼ï¼`, '#00ffff');
                    updateUI();
                    isProcessing = false;
                    return true;
                }
                return false;
            }

            window.command = async function(type) {
                if (isProcessing) return;
                isProcessing = true;
                gameStats.totalTurns++;

                const canAct = checkStatusBeforeTurn(player);
                if (canAct.sleep) {
                    log(`${player.name}ã¯çœ ã£ã¦ã„ã‚‹...`);
                } else if (canAct.confuse && Math.random() < 0.5) {
                    log(`${player.name}ã¯æ··ä¹±ã—ã¦ã„ã‚‹ï¼`);
                    const selfDmg = Math.floor(player.atk * 0.5);
                    applyDamage(player, selfDmg, false, 'player', true);
                    log(`è‡ªåˆ†ã‚’æ”»æ’ƒã—ã¦${selfDmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ffaaaa');
                } else {
                    if (type === 'attack') {
                        const dmg = calculateDamage(player.atk);
                        if (dmg.isCrit) playSE('critical'); else playSE('attack');
                        applyDamage(enemy, dmg.value, dmg.isCrit, 'enemy');
                        log(`${player.name}ã®æ”»æ’ƒï¼ ${dmg.value}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ ${dmg.isCrit ? 'ä¼šå¿ƒã®ä¸€æ’ƒï¼' : ''}`);
                    } else if (type === 'heal') {
                        playSE('heal');
                        const multiplier = isAwakened ? 0.9 : 0.4;
                        const healAmt = Math.floor(player.maxHp * (player.job === 'é­”æ³•ä½¿ã„' ? multiplier + 0.1 : multiplier));
                        player.hp = Math.min(player.maxHp, player.hp + healAmt);
                        log(`${player.name}ã¯ç¥ˆã£ãŸï¼ HPãŒ${healAmt}å›å¾©ï¼`, '#aaffaa');
                    } else if (type === 'skill') {
                        player.mp -= 1;
                        await rollDiceAndExecuteSkill();
                        if (player.job === 'æˆ¦å£«') {
                            const recoil = Math.floor(player.maxHp * (isAwakened ? 0.01 : 0.03));
                            applyDamage(player, recoil, false, 'player', true);
                            log(`ã‚¹ã‚­ãƒ«ã®åå‹•ã§HPãŒ${recoil}æ¸›å°‘ï¼`, '#ffaaaa');
                        }
                    }
                }

                updateUI();
                if (enemy.hp <= 0) {
                    const evolved = await tryEvolve();
                    if (evolved) return; 
                    await new Promise(r => setTimeout(r, 800));
                    showResult(true);
                    isProcessing = false;
                    return;
                }
                if (player.hp <= 0) { showResult(false); isProcessing = false; return; }

                await new Promise(r => setTimeout(r, 800));
                
                if (enemy.hp > 0) {
                    const enemyCanAct = checkStatusBeforeTurn(enemy);
                    if (!enemyCanAct.sleep && (!enemyCanAct.confuse || Math.random() >= 0.5)) {
                        // ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆãƒ‰ãƒ©ã‚´ãƒ³ã®ã€Œåœ°ç„ã®æ¥­ç«ã€åˆ¤å®š
                        const isBoss = enemy.name === 'ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆãƒ‰ãƒ©ã‚´ãƒ³';
                        const useHellFire = isBoss && Math.random() < 0.10; // 10%ã®ç¢ºç‡

                        if (useHellFire) {
                            playSE('cutin');
                            await playCutin('åœ°ç„ã®æ¥­ç«', 'text-red-600');
                            playSE('dark_roar');
                            
                            // é€šå¸¸ã®1.5å€ã®å¨åŠ›
                            let eDmg = Math.floor(enemy.atk * 1.5 * (0.9 + Math.random() * 0.4));
                            const avoided = applyDamage(player, eDmg, true, 'player');
                            
                            if (avoided) {
                                log(`${enemy.name}ã®åœ°ç„ã®æ¥­ç«ã‚’ã‹ã‚ã—ãŸï¼`, '#00ffff');
                            } else {
                                log(`${enemy.name}ã®åœ°ç„ã®æ¥­ç«ï¼ ${eDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff0000');
                                // ä¸ãˆãŸãƒ€ãƒ¡ãƒ¼ã‚¸åˆ†å›å¾©
                                enemy.hp = Math.min(enemy.maxHp, enemy.hp + eDmg);
                                log(`${enemy.name}ã¯åœ°ç„ã®æ¥­ç«ã§${eDmg}ã®ä½“åŠ›ã‚’å¸åã—ãŸï¼`, '#aaffaa');
                            }
                        } else {
                            // é€šå¸¸æ”»æ’ƒ
                            const isCrit = Math.random() < 0.10;
                            if (isCrit) playSE('bad_hit'); else playSE('hit');
                            let eDmg = Math.floor(enemy.atk * (0.9 + Math.random() * 0.4));
                            if (isCrit) {
                                eDmg = Math.floor(eDmg * 1.8); 
                                log(`${enemy.name}ã®ç—›æ¨ã®ä¸€æ’ƒï¼ï¼`, '#ff0000');
                            }
                            const avoided = applyDamage(player, eDmg, isCrit, 'player');
                            if (avoided) log(`${enemy.name}ã®æ”»æ’ƒã‚’ã‹ã‚ã—ãŸï¼`, '#00ffff');
                            else log(`${enemy.name}ã®æ”»æ’ƒï¼ ${eDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, isCrit ? '#ff0000' : '#ffaaaa');
                        }
                    } else if (enemyCanAct.confuse) {
                         log(`${enemy.name}ã¯æ··ä¹±ã—ã¦ã„ã‚‹ï¼`);
                         const selfDmg = Math.floor(enemy.atk * 0.5);
                         applyDamage(enemy, selfDmg, false, 'enemy', true);
                         log(`${enemy.name}ã¯è‡ªåˆ†ã‚’æ”»æ’ƒã—ã¦${selfDmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ffaaaa');
                    }
                }

                updateUI();
                applyPoison(player);
                applyPoison(enemy);
                
                if (player.hp <= 0) showResult(false);
                else if (enemy.hp <= 0) { const evolved = await tryEvolve(); if (!evolved) showResult(true); }
                isProcessing = false;
            };

            function calculateDamage(baseAtk, multiplier = 1, critChance = 0.12) {
                let isCrit = Math.random() < critChance || superCharge || chargeTurns > 0;
                let dmg = baseAtk * multiplier;
                if (isCrit) { dmg *= 3; if (chargeTurns > 0) chargeTurns--; }
                dmg = Math.floor(dmg * (0.9 + Math.random() * 0.2));
                return { value: dmg, isCrit };
            }

            function applyDamage(target, amount, isCrit, targetType, mustHit = false) {
                if (!mustHit && Math.random() < 0.05) return true;
                target.hp = Math.max(0, target.hp - amount);
                if (targetType === 'enemy') gameStats.totalDamageDealt += amount;
                else gameStats.totalDamageTaken += amount;
                const container = targetType === 'player' ? document.getElementById('player-sprite-container') : document.getElementById('enemy-sprite');
                container.classList.add('shake');
                setTimeout(() => container.classList.remove('shake'), 500);
                return false;
            }

            function checkStatusBeforeTurn(unit) {
                let res = { sleep: false, confuse: false };
                unit.status = unit.status.filter(s => {
                    if (s.type === 'sleep') { s.turns--; if (s.turns <= 0 || Math.random() < 0.3) return false; res.sleep = true; return true; }
                    if (s.type === 'confuse') { if (Math.random() < 0.2) return false; res.confuse = true; }
                    return true;
                });
                return res;
            }

            function applyPoison(unit) {
                if (unit.status.some(s => s.type === 'poison')) {
                    // ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆãƒ‰ãƒ©ã‚´ãƒ³ã¯æ¯’è€æ€§ãŒé«˜ãã€ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’10åˆ†ã®1(æœ€å¤§HPã®1%)ã«è»½æ¸›
                    const isBoss = unit.name === 'ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆãƒ‰ãƒ©ã‚´ãƒ³';
                    const dmgRatio = isBoss ? 0.01 : 0.1;
                    const dmg = Math.floor(unit.maxHp * dmgRatio);
                    applyDamage(unit, dmg, false, unit === player ? 'player' : 'enemy', true);
                    log(`${unit.name}ã¯æ¯’ã§${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼${isBoss ? 'ï¼ˆè€æ€§ã«ã‚ˆã‚Šè»½æ¸›ï¼‰' : ''}`, '#ff5555');
                }
            }

            async function rollDiceAndExecuteSkill() {
                const overlay = document.getElementById('dice-overlay');
                const anim = document.getElementById('dice-anim');
                const resName = document.getElementById('dice-result-name');
                overlay.classList.remove('hidden');
                for(let i=0; i<10; i++) {
                    playSE('dice');
                    anim.innerText = Math.floor(Math.random()*6)+1;
                    await new Promise(r => setTimeout(r, 60));
                }
                let roll = Math.floor(Math.random() * 6) + 1;
                anim.innerText = roll;
                const skill = player.skills[roll-1];
                
                const displayName = isAwakened ? `ã€æ¥µã€‘${skill.name}` : skill.name;
                resName.innerText = displayName;
                resName.className = isAwakened ? "mt-4 text-xl font-bold text-cyan-400 text-glow" : "mt-4 text-xl font-bold text-yellow-400";
                
                await new Promise(r => setTimeout(r, 800));
                overlay.classList.add('hidden');

                if (isAwakened) {
                    playSE('cutin');
                    await playCutin(`æ¥µãƒ»${skill.name}`, 'text-cyan-400');
                } else {
                    let specialCutinName = null;
                    if (player.job === 'å‹‡è€…' && roll === 1) specialCutinName = "å¿…æ®ºã®ä¸€æ’ƒ";
                    if (player.job === 'å¿è€…' && (roll === 4 || roll === 5)) specialCutinName = "æ‰‹è£å‰£ä¹±èˆ";
                    if (player.job === 'æˆ¦å£«' && roll === 1) specialCutinName = "å¥¥ç¾©ãƒ»å¤§åœ°æ–¬";
                    if (player.job === 'é­”æ³•ä½¿ã„' && roll === 6) specialCutinName = "æµæ˜Ÿç¾¤";
                    if (specialCutinName) { playSE('cutin'); await playCutin(specialCutinName, 'text-yellow-400'); }
                }
                
                playSE('skill');
                log(`${player.name}ã®ã‚¹ã‚­ãƒ«ï¼š${displayName}ï¼`, isAwakened ? '#00ffff' : '#55aaff');
                const boost = isAwakened ? 2.0 : 1.0;

                let dmgValue = 0;
                let isCrit = false;

                if (player.job === 'å‹‡è€…') {
                    if (roll === 1) {
                        const isWeak = (enemy.hp <= enemy.maxHp * 0.4) || isAwakened;
                        dmgValue = isWeak ? (isAwakened ? 1200 : 777) : calculateDamage(player.atk, 2.0 * boost, 1.0).value;
                        isCrit = true; playSE('critical');
                        applyDamage(enemy, dmgValue, isCrit, 'enemy', isWeak);
                        log(`${enemy.name}ã«${dmgValue}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff0000');
                    } else if (roll === 2) { chargeTurns = isAwakened ? 4 : 2; log(`æ”»æ’ƒåŠ›ãŒå¤§å¹…ã«é«˜ã¾ã£ãŸï¼`); }
                    else if (roll === 3) {
                        dmgValue = calculateDamage(player.atk, 1.2 * boost, 1.0).value + Math.floor(enemy.maxHp * (isAwakened ? 0.25 : 0.1));
                        playSE('critical');
                        applyDamage(enemy, dmgValue, true, 'enemy', true);
                        log(`${enemy.name}ã«${dmgValue}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff0000');
                    } else if (roll === 4 && isAwakened) {
                        log(`å¤±æ•—ã‚’ã­ã˜ä¼ã›ãŸï¼`);
                        dmgValue = calculateDamage(player.atk, 3.0).value;
                        applyDamage(enemy, dmgValue, true, 'enemy', true);
                    } else if (roll === 5 || roll === 6) {
                        dmgValue = calculateDamage(player.atk, 1.5 * boost, roll===6 ? 1.0 : 0.2).value;
                        if (roll === 6 || isAwakened) playSE('critical');
                        applyDamage(enemy, dmgValue, roll===6 || isAwakened, 'enemy', roll===6 || isAwakened);
                        player.hp = Math.min(player.maxHp, player.hp + dmgValue);
                        log(`${enemy.name}ã«${dmgValue}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€ä½“åŠ›ã‚’å›å¾©ã—ãŸï¼`);
                    }
                } else if (player.job === 'å¿è€…') {
                    if (roll === 2) { chargeTurns = isAwakened ? 5 : 2; log(`æ”»æ’ƒåŠ›ãŒå¤§å¹…ã«é«˜ã¾ã£ãŸï¼`); }
                    else if (roll === 3 || roll === 6) { 
                        if (Math.random() < (isAwakened ? 1.0 : 0.8)) { enemy.status.push({type: 'poison', turns: 99}); log(`æ•µã‚’æ¯’çŠ¶æ…‹ã«ã—ãŸï¼`); } 
                    }
                    else if (roll === 4 || roll === 5 || (roll === 1 && isAwakened)) {
                        const count = isAwakened ? 12 : 5;
                        for(let i=0; i<count; i++) {
                            playSE('attack');
                            dmgValue = Math.floor(player.atk * 0.4 * boost);
                            applyDamage(enemy, dmgValue, false, 'enemy', true);
                            updateUI();
                            await new Promise(r => setTimeout(r, 100));
                        }
                    }
                } else if (player.job === 'æˆ¦å£«') {
                    if (roll === 1 || (roll === 4 && isAwakened)) { 
                        dmgValue = calculateDamage(player.atk, 3.0 * boost).value; 
                        playSE('critical'); 
                        applyDamage(enemy, dmgValue, true, 'enemy', true); 
                        log(`${dmgValue}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff0000'); 
                    }
                    else if (roll === 2) { chargeTurns = isAwakened ? 4 : 2; log(`æ”»æ’ƒåŠ›ãŒå¤§å¹…ã«é«˜ã¾ã£ãŸï¼`); }
                    else if (roll === 3) { superCharge = true; log(`ä¼šå¿ƒç‡ãŒæ°¸ç¶šã‚¢ãƒƒãƒ—ï¼`); if(isAwakened) player.atk += 20; }
                    else if (roll === 5) { 
                        dmgValue = Math.floor(enemy.hp * (isAwakened ? 0.9 : 0.7)); 
                        playSE('bad_hit'); 
                        applyDamage(enemy, dmgValue, false, 'enemy', true); 
                        log(`${enemy.name}ã®ç”Ÿå‘½åŠ›ã‚’å¤§å¹…ã«å‰Šã‚Šå–ã£ãŸï¼`, '#ff4444'); 
                    }
                    else if (roll === 6) { 
                        dmgValue = player.atk * boost;
                        applyDamage(enemy, dmgValue, false, 'enemy', true); 
                        enemy.status.push({type:'confuse', turns: 5}); 
                        log(`${enemy.name}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€æ··ä¹±ã•ã›ãŸï¼`);
                    }
                } else if (player.job === 'é­”æ³•ä½¿ã„') {
                    if (roll === 1 || (roll === 5 && isAwakened)) { 
                        dmgValue = Math.floor(150 * boost); 
                        applyDamage(enemy, dmgValue, false, 'enemy', true); 
                        enemy.status.push({type:'confuse', turns: 4}); 
                        log(`${enemy.name}ã«${dmgValue}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€æ··ä¹±ã•ã›ãŸï¼`);
                    }
                    else if (roll === 2) { 
                        player.hp = player.maxHp; 
                        if (!isAwakened) player.status.push({type:'sleep', turns: 2}); 
                        log(`ä½“åŠ›ã‚’å…¨å›å¾©ã—ãŸï¼`);
                    }
                    else if (roll === 3) { 
                        const pRatio = player.hp / player.maxHp;
                        const eRatio = enemy.hp / enemy.maxHp;
                        const avgRatio = (pRatio + eRatio) / 2;
                        
                        player.hp = Math.floor(player.maxHp * avgRatio);
                        enemy.hp = Math.floor(enemy.maxHp * avgRatio);
                        log(`ãŠäº’ã„ã®ä½“åŠ›ã®å‰²åˆã‚’åˆ†ã‘åˆã£ãŸï¼`); 
                    }
                    else if (roll === 4) { 
                        dmgValue = calculateDamage(player.atk, 5.0 * boost).value; 
                        applyDamage(enemy, dmgValue, false, 'enemy', true); 
                        const heal = Math.floor(dmgValue * (0.2 * boost));
                        player.hp = Math.min(player.maxHp, player.hp + heal);
                        log(`${enemy.name}ã«${dmgValue}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ HPã‚’${heal}å›å¾©ã—ãŸï¼`);
                    }
                    else if (roll === 6) { 
                        dmgValue = Math.floor(enemy.hp * (isAwakened ? 0.8 : 0.4)); 
                        playSE('bad_hit'); 
                        applyDamage(enemy, dmgValue, false, 'enemy', true); 
                        enemy.status.push({type:'sleep', turns: 4}); 
                        log(`${enemy.name}ã«${dmgValue}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€çœ ã‚‰ã›ãŸï¼`);
                    }
                }
                updateUI();
            }

            function showResult(victory) {
                document.getElementById('battle-screen').classList.add('hidden');
                document.getElementById('result-screen').classList.remove('hidden');
                const title = document.getElementById('result-title');
                const msg = document.getElementById('result-message');
                const thanks = document.getElementById('thanks-message');
                
                if (victory) {
                    playSE('victory');
                    title.innerText = "âœ¨ VICTORY âœ¨";
                    if (stage >= MONSTERS.length - 1 && enemy.hasEvolved) {
                        title.innerText = "ğŸŒˆ ALL CLEAR ğŸŒˆ";
                        thanks.classList.remove('hidden');
                        document.getElementById('adventure-stats').classList.remove('hidden');
                        document.getElementById('stat-hero').innerText = `${gameStats.heroName} (${gameStats.heroJob})`;
                        document.getElementById('stat-dmg-dealt').innerText = gameStats.totalDamageDealt;
                        document.getElementById('stat-dmg-taken').innerText = gameStats.totalDamageTaken;
                        document.getElementById('stat-turns').innerText = gameStats.totalTurns;
                        document.getElementById('next-btn').classList.add('hidden');
                        document.getElementById('restart-btn').classList.remove('hidden');
                    } else {
                        msg.innerText = `${enemy.name}ã‚’å€’ã—ãŸï¼`;
                    }
                } else {
                    playSE('evolve');
                    title.innerText = "GAME OVER";
                    msg.innerText = "å†’é™ºã¯ã“ã“ã§çµ‚ã‚ã£ã¦ã—ã¾ã£ãŸ...";
                    document.getElementById('next-btn').classList.add('hidden');
                    document.getElementById('restart-btn').classList.remove('hidden');
                }
            }

            window.nextStage = function() {
                const healAmount = Math.floor(player.maxHp * 0.3);
                player.hp = Math.min(player.maxHp, player.hp + healAmount);
                stage++;
                document.getElementById('result-screen').classList.add('hidden');
                document.getElementById('battle-screen').classList.remove('hidden');
                initStage();
                log(`ä¼‘æ¯ã«ã‚ˆã‚ŠHPãŒ${healAmount}å›å¾©ã—ãŸã€‚`, '#4ade80');
            };
        })();
    </script>
</body>
</html>
