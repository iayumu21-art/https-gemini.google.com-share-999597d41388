<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã•ã„ã“ã‚ã‚¸ãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        body {
            font-family: 'DotGothic16', sans-serif;
            background-color: #1a1a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            margin: 0;
        }
        #app {
            height: 100vh;
            max-height: 100vh;
        }
        .battle-log {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(0,0,0,0.8);
            min-height: 60px;
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .dice {
            display: inline-block;
            width: 60px;
            height: 60px;
            line-height: 60px;
            text-align: center;
            background: white;
            color: black;
            border-radius: 8px;
            font-size: 32px;
            font-weight: bold;
        }
        @keyframes aura-pulse {
            0% { filter: drop-shadow(0 0 5px #fff); transform: scale(1); }
            50% { filter: drop-shadow(0 0 15px #00ffff); transform: scale(1.1); }
            100% { filter: drop-shadow(0 0 5px #fff); transform: scale(1); }
        }
        .awakened {
            animation: aura-pulse 1.5s infinite ease-in-out;
            color: #00ffff !important;
        }
        @keyframes cutin-in {
            0% { transform: translateX(-100%) skewX(-20deg); opacity: 0; }
            20% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            80% { transform: translateX(0) skewX(-20deg); opacity: 1; }
            100% { transform: translateX(100%) skewX(-20deg); opacity: 0; }
        }
        .cutin-active {
            animation: cutin-in 1.5s ease-in-out forwards;
        }
        .text-glow {
            text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px currentColor;
        }
        .flash-dark {
            animation: flash-dark-anim 1.2s ease-out;
        }
        @keyframes flash-dark-anim {
            0% { background-color: #000; opacity: 1; }
            50% { background-color: #200040; opacity: 0.8; }
            100% { background-color: transparent; opacity: 0; }
        }
        .victory-anim {
            animation: victory-zoom 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes victory-zoom {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body class="flex items-center justify-center">

    <div id="app" class="relative w-full max-w-md bg-gray-900 p-2 sm:p-4 rounded-none sm:rounded-xl shadow-2xl flex flex-col border-4 border-gray-700">
        <!-- Start Screen -->
        <div id="start-screen" class="flex-grow flex flex-col items-center justify-center overflow-y-auto">
            <h1 class="text-2xl font-bold mb-4 text-yellow-500 text-center text-glow">ã•ã„ã“ã‚ã‚¸ãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ</h1>
            <p class="mb-4 text-sm text-gray-300">å†’é™ºè€…ã‚’é¸ã‚“ã§ãã ã•ã„</p>
            
            <div class="grid grid-cols-2 gap-2 w-full mb-4">
                <button onclick="window.showDetails('ayumu')" class="bg-blue-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">âš”ï¸</div>
                    <div class="text-xs font-bold">ã‚¢ãƒ¦ãƒ  (å‹‡è€…)</div>
                </button>
                <button onclick="window.showDetails('hikaru')" class="bg-green-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ¥·</div>
                    <div class="text-xs font-bold">ãƒ’ã‚«ãƒ« (å¿è€…)</div>
                </button>
                <button onclick="window.showDetails('shunsuke')" class="bg-red-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ›¡ï¸</div>
                    <div class="text-xs font-bold">ã‚·ãƒ¥ãƒ³ã‚¹ã‚± (æˆ¦å£«)</div>
                </button>
                <button onclick="window.showDetails('hiiro')" class="bg-purple-900 p-4 rounded border-2 border-transparent hover:border-white transition text-white text-center">
                    <div class="text-4xl mb-2">ğŸ§™</div>
                    <div class="text-xs font-bold">ãƒ’ã‚¤ãƒ­ (é­”æ³•ä½¿ã„)</div>
                </button>
            </div>

            <div id="char-detail" class="hidden w-full bg-black p-3 border-2 border-yellow-500 rounded mb-2">
                <h2 id="detail-name" class="text-lg font-bold text-yellow-400"></h2>
                <div id="detail-stats" class="text-xs mb-2 text-gray-300 border-b border-gray-700 pb-2"></div>
                <div class="text-[10px] text-gray-400 font-bold mt-2 mb-1">ã€ã‚¹ã‚­ãƒ«ãƒªã‚¹ãƒˆ (ãƒ€ã‚¤ã‚¹ã®ç›®)ã€‘</div>
                <ul id="detail-skills" class="text-[9px] list-none mb-3 grid grid-cols-1 gap-1 text-gray-200"></ul>
                <button onclick="window.startGame()" class="w-full bg-yellow-600 hover:bg-yellow-500 py-2 rounded font-bold text-white text-sm">å†’é™ºã«å‡ºã‚‹</button>
            </div>
        </div>

        <!-- Battle Screen -->
        <div id="battle-screen" class="hidden h-full flex flex-col relative overflow-hidden">
            <div id="flash-overlay" class="absolute inset-0 z-50 pointer-events-none"></div>

            <!-- Cut-in Layer -->
            <div id="cutin-layer" class="pointer-events-none absolute inset-0 z-40 flex items-center justify-center opacity-0 transition-opacity duration-300">
                <div id="cutin-banner" class="w-[150%] h-24 bg-gradient-to-r from-transparent via-white/20 to-transparent border-y-4 border-white flex items-center justify-center">
                    <span id="cutin-text" class="text-4xl font-black italic tracking-tighter text-glow"></span>
                </div>
            </div>

            <!-- Enemy Area -->
            <div class="relative flex flex-col h-40 bg-gray-800 rounded-t-lg border-b-2 border-gray-700 p-2">
                <div class="w-full mb-auto">
                    <div class="flex justify-between text-xs text-white mb-1">
                        <span id="enemy-name" class="font-bold drop-shadow-lg text-white"></span>
                        <span id="enemy-hp-text" class="font-bold"></span>
                    </div>
                    <div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden border border-gray-600">
                        <div id="enemy-hp-bar" class="bg-red-500 h-full transition-all duration-300"></div>
                    </div>
                    <div id="enemy-status" class="flex mt-1 gap-1 min-h-[14px]"></div>
                </div>
                <div class="flex items-center justify-center flex-grow">
                    <div id="enemy-sprite" class="text-6xl transition-all duration-500 drop-shadow-lg">ğŸ‘¾</div>
                </div>
            </div>

            <!-- Player Area -->
            <div class="p-2 bg-gray-900 border-x-2 border-gray-700 flex flex-col items-center">
                <div id="player-sprite-container" class="mb-1 transition-transform">
                    <div id="player-sprite" class="text-4xl drop-shadow-md"></div>
                </div>
                <div class="w-full">
                    <div class="flex justify-between text-xs mb-1">
                        <span id="player-name" class="font-bold text-blue-400"></span>
                        <span id="player-hp-text"></span>
                    </div>
                    <div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden mb-1 border border-gray-600">
                        <div id="player-hp-bar" class="bg-green-500 h-full transition-all duration-300"></div>
                    </div>
                    <div class="flex justify-between text-[10px] text-gray-300">
                        <span id="player-mp-text"></span>
                        <div id="player-status" class="flex gap-1 min-h-[12px]"></div>
                    </div>
                </div>
            </div>

            <div id="battle-log" class="battle-log p-2 text-[11px] border-2 border-gray-700 bg-black font-mono leading-tight">
                <div>å†’é™ºãŒå§‹ã¾ã£ãŸï¼</div>
            </div>

            <div id="action-panel" class="grid grid-cols-2 gap-1 p-2 bg-gray-800 rounded-b-lg border-t-2 border-gray-700">
                <button onclick="window.command('attack')" class="bg-red-700 hover:bg-red-600 py-2 rounded text-white font-bold text-sm border-b-2 border-red-900">æ”»æ’ƒ</button>
                <button onclick="window.command('heal')" class="bg-emerald-700 hover:bg-emerald-600 py-2 rounded text-white font-bold text-sm border-b-2 border-emerald-900">å›å¾©</button>
                <button id="skill-btn" onclick="window.command('skill')" class="bg-blue-700 hover:bg-blue-600 py-2 rounded col-span-2 text-white font-bold text-sm border-b-2 border-blue-900">ã‚¹ã‚­ãƒ« (MP 1)</button>
            </div>
        </div>

        <!-- Result Screen -->
        <div id="result-screen" class="hidden flex-grow flex flex-col items-center justify-center text-center z-50 overflow-y-auto pt-4 pb-4">
            <h2 id="result-title" class="text-3xl font-bold mb-4 drop-shadow-lg victory-anim"></h2>
            <div id="adventure-stats" class="w-full px-4 mb-4 hidden">
                <div class="bg-black/60 border-2 border-yellow-600 rounded-lg p-3 text-left">
                    <h3 class="text-yellow-400 font-bold border-b border-yellow-800 mb-2 pb-1 text-center">âœ¨ å†’é™ºã®è¨˜éŒ² âœ¨</h3>
                    <div class="grid grid-cols-1 gap-2 text-sm">
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">è·æ¥­:</span>
                            <span id="stat-hero" class="text-white font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">ç·ä¸ãƒ€ãƒ¡:</span>
                            <span id="stat-dmg-dealt" class="text-red-400 font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">ç·è¢«ãƒ€ãƒ¡:</span>
                            <span id="stat-dmg-taken" class="text-orange-400 font-bold"></span>
                        </div>
                        <div class="flex justify-between border-b border-gray-800 py-1">
                            <span class="text-gray-400">ã‚¿ãƒ¼ãƒ³æ•°:</span>
                            <span id="stat-turns" class="text-blue-400 font-bold"></span>
                        </div>
                    </div>
                </div>
            </div>
            <div id="result-message" class="text-sm text-white px-4 mb-4 leading-relaxed"></div>
            <div id="thanks-message" class="hidden text-lg font-bold text-yellow-500 mb-6 animate-pulse">ãƒ—ãƒ¬ã‚¤ã—ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ï¼</div>
            <div class="flex flex-col gap-2 w-full px-8">
                <button id="next-btn" onclick="window.nextStage()" class="bg-yellow-600 hover:bg-yellow-500 py-3 rounded font-bold text-white text-sm shadow-lg">æ¬¡ã®ã‚¨ãƒªã‚¢ã¸</button>
                <button id="restart-btn" onclick="location.reload()" class="hidden bg-gray-600 hover:bg-gray-500 py-3 rounded font-bold text-white text-sm">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
            </div>
        </div>

        <!-- Dice Overlay -->
        <div id="dice-overlay" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
            <div class="text-center p-6 bg-gray-900 rounded-2xl border-2 border-yellow-500 shadow-2xl">
                <div id="dice-anim" class="dice shadow-lg">?</div>
                <div id="dice-result-name" class="mt-4 text-xl font-bold text-yellow-400"></div>
            </div>
        </div>
    </div>

    <script>
        (function() {
            // Audio Helper
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            function playSE(type) {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const now = audioCtx.currentTime;
                const createGrumble = (freq, duration, gainVal) => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); const lfo = audioCtx.createOscillator(); const lfoGain = audioCtx.createGain();
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, now); osc.frequency.exponentialRampToValueAtTime(freq / 2.5, now + duration);
                    lfo.type = 'sine'; lfo.frequency.setValueAtTime(15, now); lfoGain.gain.setValueAtTime(freq * 0.2, now);
                    lfo.connect(lfoGain); lfoGain.connect(osc.frequency); osc.connect(gain); gain.connect(audioCtx.destination);
                    gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(gainVal, now + 0.1); gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                    lfo.start(now); osc.start(now); lfo.stop(now + duration); osc.stop(now + duration);
                };
                switch(type) {
                    case 'attack': { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'square'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(110, now + 0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.1); break; }
                    case 'hit': { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(220, now); osc.frequency.linearRampToValueAtTime(50, now + 0.1); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.1); break; }
                    case 'critical': { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(110, now); osc.frequency.exponentialRampToValueAtTime(880, now + 0.15); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.15); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.15); break; }
                    case 'heal': { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(880, now + 0.3); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.3); break; }
                    case 'dice': { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(880, now); gain.gain.setValueAtTime(0.05, now); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.05); break; }
                    case 'skill': { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'square'; osc.frequency.setValueAtTime(110, now); osc.frequency.exponentialRampToValueAtTime(660, now + 0.4); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(now + 0.4); break; }
                    case 'cutin': [880, 1100, 1320].forEach((f, i) => { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'sine'; o.connect(g); g.connect(audioCtx.destination); o.frequency.setValueAtTime(f, now + i * 0.05); g.gain.setValueAtTime(0.1, now + i * 0.05); g.gain.linearRampToValueAtTime(0, now + i * 0.05 + 0.5); o.start(now + i * 0.05); o.stop(now + i * 0.05 + 0.5); }); break;
                    case 'victory': [440, 554, 659].forEach((f, i) => { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'square'; o.connect(g); g.connect(audioCtx.destination); o.frequency.setValueAtTime(f, now + i * 0.1); g.gain.setValueAtTime(0.05, now + i * 0.1); g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.4); o.start(now + i * 0.1); o.stop(now + i * 0.1 + 0.4); }); break;
                    case 'evolve': { createGrumble(80, 2.0, 0.4); createGrumble(60, 2.5, 0.3); break; }
                    case 'dark_roar': { createGrumble(55, 1.5, 0.5); createGrumble(73, 1.2, 0.4); createGrumble(38, 1.8, 0.3); break; }
                }
            }

            const CHARACTERS = {
                ayumu: { name: 'ã‚¢ãƒ¦ãƒ ', job: 'å‹‡è€…', icon: 'âš”ï¸', maxHp: 400, atk: 30, maxMp: 5, skills: [{ name: 'å¿…æ®ºã®ä¸€æ’ƒ', desc: 'å¼±ã£ã¦ã„ã‚‹æ•µã«å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸' }, { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®æ”»æ’ƒãŒ3å€' }, { name: 'å¸Œæœ›ã®ä¸€æŒ¯ã‚Š', desc: 'ä¼šå¿ƒã®ä¸€æ’ƒ + æœ€å¤§HPå‰²åˆãƒ€ãƒ¡' }, { name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„' }, { name: 'ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒ‰', desc: 'ãƒ€ãƒ¡ãƒ¼ã‚¸ + å¸åå›å¾©' }, { name: 'ãƒŸãƒ©ã‚¯ãƒ«ã‚½ãƒ¼ãƒ‰æ”¹', desc: 'å¿…ä¸­ä¼šå¿ƒ + å¸åå›å¾©' }] },
                hikaru: { name: 'ãƒ’ã‚«ãƒ«', job: 'å¿è€…', icon: 'ğŸ¥·', maxHp: 280, atk: 45, maxMp: 5, skills: [{ name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„' }, { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®æ”»æ’ƒãŒ3å€' }, { name: 'æ¯’çŸ¢', desc: 'æ•µã‚’æ¯’çŠ¶æ…‹ã«ã™ã‚‹' }, { name: 'æ‰‹è£å‰£', desc: 'å¨åŠ›35%Ã—5å›é€£ç¶šæ”»æ’ƒ' }, { name: 'æ‰‹è£å‰£', desc: 'å¨åŠ›35%Ã—5å›é€£ç¶šæ”»æ’ƒ' }, { name: 'æ¯’çŸ¢', desc: 'æ•µã‚’æ¯’çŠ¶æ…‹ã«ã™ã‚‹' }] },
                shunsuke: { name: 'ã‚·ãƒ¥ãƒ³ã‚¹ã‚±', job: 'æˆ¦å£«', icon: 'ğŸ›¡ï¸', maxHp: 520, atk: 35, maxMp: 3, skills: [{ name: 'å¤§åœ°æ–¬', desc: 'æ”»æ’ƒåŠ›ã®2.5å€ãƒ€ãƒ¡ (åå‹•ã‚ã‚Š)' }, { name: 'ãŸã‚ã‚‹', desc: 'æ¬¡ã®æ”»æ’ƒãŒ3å€' }, { name: 'è¶…ãŸã‚ã‚‹', desc: 'ä¼šå¿ƒç‡UP' }, { name: 'å¤±æ•—', desc: 'ä½•ã‚‚ãŠããªã„ (åå‹•ã‚ã‚Š)' }, { name: 'æ­»ã®ä¸€æŒ¯ã‚Š', desc: 'ç¾åœ¨ã®HPã®70%ã‚’å‰Šã‚‹' }, { name: 'ã“ã‚“ã‚‰ã‚“æ”»æ’ƒ', desc: 'ãƒ€ãƒ¡+æ··ä¹±ä»˜ä¸' }] },
                hiiro: { name: 'ãƒ’ã‚¤ãƒ­', job: 'é­”æ³•ä½¿ã„', icon: 'ğŸ§™', maxHp: 330, atk: 20, maxMp: 10, skills: [{ name: 'ã‚¹ã‚¿ãƒ¼ãƒ€ã‚¹ãƒˆ', desc: 'å›ºå®šãƒ€ãƒ¡ãƒ¼ã‚¸ + æ··ä¹±' }, { name: 'çœ ã‚‹', desc: 'å…¨å›å¾© + ç¡çœ çŠ¶æ…‹' }, { name: 'ç—›ã¿åˆ†ã‘', desc: 'ãŠäº’ã„ã®HPå‰²åˆã‚’å¹³å‡åŒ–' }, { name: 'ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã‚¢ãƒ­ãƒ¼', desc: 'é«˜å€ç‡ãƒ€ãƒ¡ + å›å¾©' }, { name: 'å¤±æ•—', desc: 'æš´èµ°ï¼è‡ªåˆ†ã«ãƒ€ãƒ¡ãƒ¼ã‚¸' }, { name: 'ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¹ã‚¿ãƒ¼', desc: 'å‰²åˆãƒ€ãƒ¡ãƒ¼ã‚¸ + ç¡çœ ' }] }
            };

            const MONSTERS = [
                { name: 'ã‚¹ãƒ©ã‚¤ãƒ ', icon: 'ğŸ’§', hp: 120, atk: 18 },
                { name: 'ã‚´ãƒ–ãƒªãƒ³', icon: 'ğŸ‘º', hp: 200, atk: 28 },
                { name: 'ã‚ªãƒ¼ã‚¯', icon: 'ğŸ—', hp: 350, atk: 42 },
                { name: 'ãƒ‰ãƒ©ã‚´ãƒ³', icon: 'ğŸ²', hp: 650, atk: 60, hasEvolved: false }
            ];

            let player, enemy, stage = 0, selectedKey = '';
            let gameStats = { heroName: '', heroJob: '', totalDamageDealt: 0, totalDamageTaken: 0, totalTurns: 0 };
            let chargeTurns = 0, superCharge = false, isProcessing = false, isAwakened = false;

            window.showDetails = function(key) {
                playSE('dice'); selectedKey = key; const c = CHARACTERS[key];
                document.getElementById('char-detail').classList.remove('hidden');
                document.getElementById('detail-name').innerText = `${c.name} (${c.job})`;
                document.getElementById('detail-stats').innerText = `HP: ${c.maxHp} / ATK: ${c.atk} / MP: ${c.maxMp}`;
                const skillList = document.getElementById('detail-skills'); skillList.innerHTML = '';
                c.skills.forEach((s, i) => { const li = document.createElement('li'); li.className = "border-l-2 border-yellow-700 pl-2 py-0.5 text-left"; li.innerHTML = `<span class="text-yellow-500 font-bold">${i+1}. ${s.name}</span>: <span class="text-gray-400 text-[8px]">${s.desc}</span>`; skillList.appendChild(li); });
            };

            window.startGame = function() {
                playSE('victory'); if (!selectedKey) return; const base = CHARACTERS[selectedKey];
                player = { ...base, hp: base.maxHp, mp: base.maxMp, status: [] };
                gameStats = { heroName: base.name, heroJob: base.job, totalDamageDealt: 0, totalDamageTaken: 0, totalTurns: 0 };
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('battle-screen').classList.remove('hidden');
                document.getElementById('player-sprite').innerText = player.icon;
                initStage();
            };

            function initStage() {
                const m = MONSTERS[stage]; enemy = { ...m, maxHp: m.hp, hp: m.hp, status: [] }; player.mp = player.maxMp; chargeTurns = 0; isAwakened = false;
                document.getElementById('player-sprite').classList.remove('awakened'); if (player.job !== 'æˆ¦å£«') superCharge = false;
                updateUI(); log(`ã‚¨ãƒªã‚¢${stage + 1}: ${enemy.name}ãŒç¾ã‚ŒãŸï¼`);
            }

            function log(msg, color = 'white') {
                const div = document.createElement('div'); div.style.color = color; div.innerText = "> " + msg;
                const box = document.getElementById('battle-log'); box.appendChild(div); box.scrollTop = box.scrollHeight;
            }

            function updateUI() {
                if(!player || !enemy) return;
                const nameEl = document.getElementById('player-name');
                nameEl.innerText = `${player.name} (${player.job})${isAwakened ? " (è¦šé†’)" : ""}`;
                document.getElementById('player-hp-text').innerText = `HP ${Math.ceil(player.hp)}/${player.maxHp}`;
                document.getElementById('player-hp-bar').style.width = `${(player.hp / player.maxHp) * 100}%`;
                document.getElementById('player-mp-text').innerText = `MP ${player.mp}/${player.maxMp}`;
                document.getElementById('enemy-name').innerText = enemy.name;
                document.getElementById('enemy-sprite').innerText = enemy.icon;
                document.getElementById('enemy-hp-text').innerText = `HP ${Math.ceil(enemy.hp)}/${enemy.maxHp}`;
                document.getElementById('enemy-hp-bar').style.width = `${(enemy.hp / enemy.maxHp) * 100}%`;
                const pStatus = document.getElementById('player-status'); pStatus.innerHTML = '';
                player.status.forEach(s => { const span = document.createElement('span'); span.className = "px-1 bg-red-900 text-[8px] border border-red-500 rounded text-white"; span.innerText = s.type === 'poison' ? 'æ¯’' : s.type === 'confuse' ? 'æ··' : 'çœ '; pStatus.appendChild(span); });
                const eStatus = document.getElementById('enemy-status'); eStatus.innerHTML = '';
                enemy.status.forEach(s => { const span = document.createElement('span'); span.className = "px-1 bg-red-900 text-[8px] border border-red-500 rounded text-white"; span.innerText = s.type === 'poison' ? 'æ¯’' : s.type === 'confuse' ? 'æ··' : 'çœ '; eStatus.appendChild(span); });
                const skillBtn = document.getElementById('skill-btn');
                if (player.mp < 1) skillBtn.classList.add('opacity-50', 'pointer-events-none'); else skillBtn.classList.remove('opacity-50', 'pointer-events-none');
            }

            async function playCutin(skillName, colorClass = 'text-white') {
                const layer = document.getElementById('cutin-layer'); const banner = document.getElementById('cutin-banner'); const text = document.getElementById('cutin-text');
                text.innerText = skillName; text.className = `text-4xl font-black italic tracking-tighter text-glow ${colorClass}`;
                layer.classList.remove('opacity-0'); banner.classList.add('cutin-active'); await new Promise(r => setTimeout(r, 1500));
                banner.classList.remove('cutin-active'); layer.classList.add('opacity-0');
            }

            async function tryEvolve() {
                if (enemy.name === 'ãƒ‰ãƒ©ã‚´ãƒ³' && !enemy.hasEvolved) {
                    isProcessing = true; playSE('evolve'); log(`ãƒ‰ãƒ©ã‚´ãƒ³ã‚’å€’ã—ãŸ...ã—ã‹ã—ã€å‘¨å›²ã®ç©ºæ°—ãŒä¸€å¤‰ã™ã‚‹ã€‚`, '#6600cc');
                    await new Promise(r => setTimeout(r, 1500));
                    const flash = document.getElementById('flash-overlay'); flash.classList.add('flash-dark'); setTimeout(() => flash.classList.remove('flash-dark'), 1200);
                    enemy.name = 'é‚ªé¾ç‹ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆ'; enemy.icon = 'ğŸ”±ğŸ²'; enemy.maxHp = 999; enemy.hp = 999; enemy.atk = 85; enemy.hasEvolved = true; enemy.status = [];
                    log(`ä¼èª¬ã®é‚ªé¾ã€Œé‚ªé¾ç‹ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆã€ãŒè¦šé†’ã—ãŸï¼`, '#ff0000'); await new Promise(r => setTimeout(r, 1000));
                    playSE('dark_roar'); await playCutin('æ·±æ·µã®å’†å“®', 'text-purple-600');
                    const preDmg = Math.floor(player.maxHp * 0.25); applyDamage(player, preDmg, false, 'player', true);
                    log(`å‡„ã¾ã˜ã„æ³¢å‹•ï¼ ${player.name}ã¯${preDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff4400');
                    isAwakened = true; playSE('victory'); player.maxMp += 2; player.mp = player.maxMp; player.atk = Math.floor(player.atk * 1.3);
                    document.getElementById('player-sprite').classList.add('awakened'); log(`${player.name}ãŒè¦šé†’ï¼ ã‚¹ã‚­ãƒ«ãŒæ¥µé™é€²åŒ–ã—ãŸï¼`, '#00ffff');
                    updateUI(); isProcessing = false; return true;
                }
                return false;
            }

            window.command = async function(type) {
                if (isProcessing) return; isProcessing = true; gameStats.totalTurns++;
                const pCanAct = checkStatusBeforeTurn(player);
                if (pCanAct.sleep) log(`${player.name}ã¯çœ ã£ã¦ã„ã‚‹...`);
                else if (pCanAct.confuse && Math.random() < 0.5) {
                    log(`${player.name}ã¯æ··ä¹±ã—ã¦ã„ã‚‹ï¼`); const selfDmg = Math.floor(player.atk * 0.5); applyDamage(player, selfDmg, false, 'player', true); log(`è‡ªåˆ†ã‚’æ”»æ’ƒã—ã€${selfDmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ffaaaa');
                } else {
                    if (type === 'attack') {
                        const dmg = calculateDamage(player.atk); if (dmg.isCrit) playSE('critical'); else playSE('attack');
                        applyDamage(enemy, dmg.value, dmg.isCrit, 'enemy'); log(`${player.name}ã®æ”»æ’ƒï¼ ${enemy.name}ã«${dmg.value}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ ${dmg.isCrit ? 'ä¼šå¿ƒï¼' : ''}`);
                    } else if (type === 'heal') {
                        playSE('heal');
                        const minR = 0.20; const maxR = 0.40;
                        const ratio = minR + (Math.random() * (maxR - minR));
                        const awakeningBonus = isAwakened ? 0.05 : 0;
                        const jobBonus = (player.job === 'é­”æ³•ä½¿ã„' ? 0.05 : 0);
                        const healAmt = Math.floor(player.maxHp * (ratio + awakeningBonus + jobBonus));
                        player.hp = Math.min(player.maxHp, player.hp + healAmt);
                        log(`${player.name}ã¯ç²¾ç¥ã‚’é›†ä¸­ã—ãŸã€‚HPãŒ${healAmt}å›å¾©ï¼`, '#aaffaa');
                    } else if (type === 'skill') {
                        player.mp -= 1; await rollDiceAndExecuteSkill();
                        if (player.job === 'æˆ¦å£«') { const recoil = Math.floor(player.maxHp * (isAwakened ? 0.01 : 0.03)); applyDamage(player, recoil, false, 'player', true); log(`åå‹•ã§HPãŒ${recoil}æ¸›å°‘ï¼`, '#ffaaaa'); }
                    }
                }
                updateUI();
                if (enemy.hp <= 0) { const evolved = await tryEvolve(); if (evolved) return; await new Promise(r => setTimeout(r, 800)); showResult(true); isProcessing = false; return; }
                if (player.hp <= 0) { showResult(false); isProcessing = false; return; }
                await new Promise(r => setTimeout(r, 800));
                if (enemy.hp > 0) {
                    const eCanAct = checkStatusBeforeTurn(enemy);
                    if (!eCanAct.sleep && (!eCanAct.confuse || Math.random() >= 0.5)) {
                        const isBoss = enemy.name === 'é‚ªé¾ç‹ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆ';
                        if (isBoss && Math.random() < 0.15) {
                            playSE('cutin'); await playCutin('åœ°ç„ã®æ¥­ç«', 'text-red-500'); playSE('dark_roar');
                            let fireDmg = Math.floor(enemy.atk * 1.5 * (0.9 + Math.random() * 0.4));
                            const prevHP = player.hp; const dodged = applyDamage(player, fireDmg, true, 'player');
                            if (dodged) log(`${enemy.name}ã®æ¥­ç«ã‚’å›é¿ï¼`, '#00ffff');
                            else { const realDmg = prevHP - player.hp; log(`${enemy.name}ã®æ¥­ç«ï¼ ${realDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff0000'); if (realDmg > 0) { enemy.hp = Math.min(enemy.maxHp, enemy.hp + realDmg); log(`${enemy.name}ã¯ç”Ÿå‘½åŠ›ã‚’å¸åã€${realDmg}å›å¾©ï¼`, '#aaffaa'); } }
                        } else {
                            const isCrit = Math.random() < 0.12; if (isCrit) playSE('critical'); else playSE('hit');
                            let eDmg = Math.floor(enemy.atk * (0.8 + Math.random() * 0.4)); if (isCrit) eDmg = Math.floor(eDmg * 2.0);
                            const dodged = applyDamage(player, eDmg, isCrit, 'player');
                            if (dodged) log(`${enemy.name}ã®æ”»æ’ƒã‚’å›é¿ï¼`, '#00ffff'); else log(`${enemy.name}ã®æ”»æ’ƒï¼ ${eDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, isCrit ? '#ff0000' : '#ffaaaa');
                        }
                    } else if (eCanAct.confuse) { log(`${enemy.name}ã¯æ··ä¹±ã—ã€è‡ªåˆ†ã‚’æ”»æ’ƒï¼`); const selfDmg = Math.floor(enemy.atk * 0.5); applyDamage(enemy, selfDmg, false, 'enemy', true); log(`${enemy.name}ã«${selfDmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ffaaaa'); }
                }
                updateUI(); applyPoisonDamage(player); applyPoisonDamage(enemy);
                if (player.hp <= 0) showResult(false); else if (enemy.hp <= 0) { const evolved = await tryEvolve(); if (!evolved) showResult(true); }
                isProcessing = false;
            };

            function calculateDamage(baseAtk, multiplier = 1, critChance = 0.15) {
                let isCrit = Math.random() < critChance || superCharge || chargeTurns > 0;
                let dmg = baseAtk * multiplier; if (isCrit) { dmg *= 3; if (chargeTurns > 0) chargeTurns--; }
                dmg = Math.floor(dmg * (0.9 + Math.random() * 0.2)); return { value: dmg, isCrit };
            }

            function applyDamage(target, amount, isCrit, targetType, mustHit = false) {
                if (!mustHit && Math.random() < 0.05) return true;
                target.hp = Math.max(0, target.hp - amount);
                if (targetType === 'enemy') gameStats.totalDamageDealt += amount; else gameStats.totalDamageTaken += amount;
                const container = targetType === 'player' ? document.getElementById('player-sprite-container') : document.getElementById('enemy-sprite');
                container.classList.add('shake'); setTimeout(() => container.classList.remove('shake'), 500); return false;
            }

            function checkStatusBeforeTurn(unit) {
                let res = { sleep: false, confuse: false };
                unit.status = unit.status.filter(s => {
                    if (s.type === 'sleep') { s.turns--; if (s.turns <= 0 || Math.random() < 0.3) return false; res.sleep = true; return true; }
                    if (s.type === 'confuse') { if (Math.random() < 0.2) return false; res.confuse = true; }
                    return true;
                });
                return res;
            }

            function applyPoisonDamage(unit) {
                if (unit.status.some(s => s.type === 'poison')) {
                    const isBoss = unit.name.includes('ã‚¢ãƒ«ãƒ†ã‚£ãƒ¡ãƒƒãƒˆ');
                    const dmg = Math.floor(unit.maxHp * (isBoss ? 0.01 : 0.08));
                    applyDamage(unit, dmg, false, unit === player ? 'player' : 'enemy', true);
                    log(`${unit.name}ã¯æ¯’ã«ã‚ˆã‚Š${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff5555');
                }
            }

            async function rollDiceAndExecuteSkill() {
                const overlay = document.getElementById('dice-overlay'); const anim = document.getElementById('dice-anim'); const resName = document.getElementById('dice-result-name');
                overlay.classList.remove('hidden'); for(let i=0; i<10; i++) { playSE('dice'); anim.innerText = Math.floor(Math.random()*6)+1; await new Promise(r => setTimeout(r, 60)); }
                let roll = Math.floor(Math.random() * 6) + 1; anim.innerText = roll; const skill = player.skills[roll-1];
                
                const isFailSkill = skill.name.includes('å¤±æ•—');
                const displayName = (isAwakened && !isFailSkill) ? `ã€æ¥µã€‘${skill.name}` : skill.name;
                
                resName.innerText = displayName; 
                resName.className = (isAwakened && !isFailSkill) ? "mt-4 text-xl font-bold text-cyan-400 text-glow" : "mt-4 text-xl font-bold text-yellow-400";
                
                await new Promise(r => setTimeout(r, 800)); overlay.classList.add('hidden');
                
                if (isAwakened && !isFailSkill) { 
                    playSE('cutin'); await playCutin(`æ¥µãƒ»${skill.name}`, 'text-cyan-400'); 
                } else if (!isFailSkill) {
                    let cutin = null;
                    if (player.job === 'å‹‡è€…' && roll === 1) cutin = "å¿…æ®ºã®ä¸€æ’ƒ"; 
                    if (player.job === 'å¿è€…' && (roll === 4 || roll === 5)) cutin = "æ‰‹è£å‰£ä¹±èˆ";
                    if (player.job === 'æˆ¦å£«' && roll === 1) cutin = "å¥¥ç¾©ãƒ»å¤§åœ°æ–¬"; 
                    if (player.job === 'é­”æ³•ä½¿ã„' && (roll === 4 || roll === 6)) cutin = "å¤§é­”è¡“";
                    if (cutin) { playSE('cutin'); await playCutin(cutin, 'text-yellow-400'); }
                }
                
                playSE('skill'); 
                log(`${player.name}ã®å¥¥ç¾©ï¼š${displayName}ï¼`, (isAwakened && !isFailSkill) ? '#00ffff' : '#55aaff');
                
                // ãƒãƒ©ãƒ³ã‚¹èª¿æ•´: æˆ¦å£«(ã‚·ãƒ¥ãƒ³ã‚¹ã‚±)ã®ã¿è¦šé†’å€ç‡ã‚’1.5å€ã«æŠ‘ãˆã‚‹ã€‚ä»–ã¯2.0å€ã€‚
                const jobAwakeBoost = (player.job === 'æˆ¦å£«') ? 1.5 : 2.0;
                const boost = (isAwakened && !isFailSkill) ? jobAwakeBoost : 1.0; 
                let dmg = 0;

                if (player.job === 'å‹‡è€…') {
                    if (roll === 1) { const isLowHP = (enemy.hp <= enemy.maxHp * 0.4) || isAwakened; dmg = isLowHP ? (isAwakened ? 1200 : 777) : calculateDamage(player.atk, 2.5 * boost, 1.0).value; applyDamage(enemy, dmg, true, 'enemy', isLowHP); log(`${enemy.name}ã«${dmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff0000'); }
                    else if (roll === 2) { chargeTurns = isAwakened ? 5 : 2; log(`åŠ›ãŒã¿ãªãã‚‹ï¼`); }
                    else if (roll === 3) { dmg = calculateDamage(player.atk, 1.2 * boost, 1.0).value + Math.floor(enemy.maxHp * (isAwakened ? 0.3 : 0.12)); applyDamage(enemy, dmg, true, 'enemy', true); log(`${enemy.name}ã«${dmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff0000'); }
                    else if (roll === 4) { log(`ã—ã‹ã—ä½•ã‚‚èµ·ããªã‹ã£ãŸã€‚`); }
                    else if (roll === 5 || roll === 6) { dmg = calculateDamage(player.atk, 1.5 * boost, roll===6 ? 1.0 : 0.3).value; const preHP = enemy.hp; applyDamage(enemy, dmg, roll===6 || isAwakened, 'enemy', roll===6 || isAwakened); const heal = preHP - enemy.hp; player.hp = Math.min(player.maxHp, player.hp + heal); log(`${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆ${heal}å›å¾©ï¼`); }
                } else if (player.job === 'å¿è€…') {
                    if (roll === 1) { log(`ã—ã‹ã—ä½•ã‚‚èµ·ããªã‹ã£ãŸã€‚`); }
                    else if (roll === 2) { chargeTurns = isAwakened ? 5 : 2; log(`æ®ºæ°—ãŒé«˜ã¾ã‚‹ï¼`); }
                    else if (roll === 3 || roll === 6) { if (Math.random() < (isAwakened ? 1.0 : 0.8)) { enemy.status.push({type: 'poison', turns: 99}); log(`${enemy.name}ã‚’çŒ›æ¯’ã«ã—ãŸï¼`); } }
                    else if (roll === 4 || roll === 5) {
                        const count = isAwakened ? 12 : 5; let total = 0;
                        for(let i=0; i<count; i++) { playSE('attack'); let tick = Math.floor(player.atk * 0.45 * boost * (0.8 + Math.random() * 0.4)); applyDamage(enemy, tick, false, 'enemy', true); total += tick; updateUI(); await new Promise(r => setTimeout(r, 800)); }
                        log(`é€£ç¶šæ”»æ’ƒï¼ åˆè¨ˆ${total}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
                    }
                } else if (player.job === 'æˆ¦å£«') {
                    if (roll === 1) { dmg = calculateDamage(player.atk, 2.5 * boost).value; applyDamage(enemy, dmg, true, 'enemy', true); log(`${enemy.name}ã«${dmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff0000'); }
                    else if (roll === 2) { chargeTurns = isAwakened ? 4 : 2; log(`ç­‹è‚‰è†¨å¼µï¼`); }
                    else if (roll === 3) { superCharge = true; log(`ä¼šå¿ƒç‡é™ç•Œçªç ´ï¼`); if(isAwakened) player.atk += 15; }
                    else if (roll === 4) { log(`ã—ã‹ã—ä½•ã‚‚èµ·ããªã‹ã£ãŸã€‚`); }
                    else if (roll === 5) { dmg = Math.floor(enemy.hp * (isAwakened ? 0.8 : 0.7)); applyDamage(enemy, dmg, false, 'enemy', true); log(`${enemy.name}ã«${dmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ff4444'); }
                    else if (roll === 6) { dmg = calculateDamage(player.atk, 1.2 * boost).value; applyDamage(enemy, dmg, false, 'enemy', true); enemy.status.push({type:'confuse', turns: 5}); log(`${enemy.name}ã‚’æ··ä¹±ã•ã›ãŸï¼`); }
                } else if (player.job === 'é­”æ³•ä½¿ã„') {
                    if (roll === 1) { dmg = Math.floor(180 * boost); applyDamage(enemy, dmg, false, 'enemy', true); enemy.status.push({type:'confuse', turns: 4}); log(`${enemy.name}ã«${dmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã¨æ··ä¹±ï¼`); }
                    else if (roll === 2) { player.hp = player.maxHp; if (!isAwakened) player.status.push({type:'sleep', turns: 2}); log(`é­”åŠ›ã§å…¨å›å¾©ï¼`); }
                    else if (roll === 3) { const pR = player.hp / player.maxHp; const eR = enemy.hp / enemy.maxHp; const avg = (pR + eR) / 2; player.hp = Math.floor(player.maxHp * avg); enemy.hp = Math.floor(enemy.maxHp * avg); log(`HPå‰²åˆã‚’å¹³å‡åŒ–ã—ãŸï¼`); }
                    else if (roll === 4) { dmg = calculateDamage(player.atk, 5.5 * boost).value; const before = enemy.hp; applyDamage(enemy, dmg, false, 'enemy', true); const heal = Math.floor((before - enemy.hp) * (0.25 * boost)); player.hp = Math.min(player.maxHp, player.hp + heal); log(`${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€${heal}å›å¾©ï¼`); }
                    else if (roll === 5) { let sDmg = Math.floor(player.maxHp * 0.15); applyDamage(player, sDmg, false, 'player', true); log(`é­”åŠ›ãŒæš´èµ°ï¼ è‡ªåˆ†ã«${sDmg}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, '#ffaaaa'); }
                    else if (roll === 6) { dmg = Math.floor(enemy.hp * (isAwakened ? 0.85 : 0.45)); applyDamage(enemy, dmg, false, 'enemy', true); enemy.status.push({type:'sleep', turns: 4}); log(`${enemy.name}ã«${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ã¨ç¡çœ ï¼`); }
                }
                updateUI();
            }

            function showResult(victory) {
                document.getElementById('battle-screen').classList.add('hidden');
                document.getElementById('result-screen').classList.remove('hidden');
                const title = document.getElementById('result-title');
                const msg = document.getElementById('result-message');
                const thanks = document.getElementById('thanks-message');
                if (victory) {
                    playSE('victory'); title.innerText = "âœ¨ VICTORY âœ¨";
                    if (stage >= MONSTERS.length - 1 && enemy.hasEvolved) {
                        title.innerText = "ğŸŒˆ ALL CLEAR ğŸŒˆ"; thanks.classList.remove('hidden');
                        document.getElementById('adventure-stats').classList.remove('hidden');
                        document.getElementById('stat-hero').innerText = `${gameStats.heroName} (${gameStats.heroJob})`;
                        document.getElementById('stat-dmg-dealt').innerText = gameStats.totalDamageDealt;
                        document.getElementById('stat-dmg-taken').innerText = gameStats.totalDamageTaken;
                        document.getElementById('stat-turns').innerText = gameStats.totalTurns;
                        document.getElementById('next-btn').classList.add('hidden');
                        document.getElementById('restart-btn').classList.remove('hidden');
                        msg.innerText = `${enemy.name}ã‚’è¨ã¡æœãŸã—ã€ä¸–ç•Œã®å¹³å’Œã‚’å–ã‚Šæˆ»ã—ãŸï¼`;
                    } else {
                        msg.innerText = `${enemy.name}ã‚’å€’ã—ãŸï¼`;
                    }
                } else {
                    title.innerText = "GAME OVER"; msg.innerText = "å†’é™ºã¯ã“ã“ã§å¹•ã‚’é–‰ã˜ãŸ...";
                    document.getElementById('next-btn').classList.add('hidden'); document.getElementById('restart-btn').classList.remove('hidden');
                }
            }

            window.nextStage = function() {
                const ratio = 0.2 + (Math.random() * 0.1); const healAmt = Math.floor(player.maxHp * ratio);
                player.hp = Math.min(player.maxHp, player.hp + healAmt); stage++;
                document.getElementById('result-screen').classList.add('hidden'); document.getElementById('battle-screen').classList.remove('hidden');
                initStage(); log(`HPãŒ${healAmt}å›å¾©ã—ãŸã€‚`, '#4ade80');
            };
        })();
    </script>
</body>
</html>
